# Android Framework学习的第一部分：进程间通信框架binder

binder是google专门为了android设计的进程间通信框架，但是在linux系统中存在很多的进程间通信方式，为什么要单独写一个？带着这个问题，仔细分析学习。

## 1 linux中进程相关的基本概念梳理：

### 1.1 linux内核的划分：
Linux将系统内存划分成了 *内核空间* 和 *用户空间* 两部分：
> - 系统的核心软件会运行在较高的特权级别上，它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，Linux将此块内存称为内核空间。
> - 普通应用程序则运行在用户空间上，它们不能使用某些特定的系统功能，不能直接访问硬件，不能直接访问内核空间等。

高安全级别的东西（硬件等）只能由内核空间里的程序访问，那么当普通程序也需要访问这些资源时，该怎么办呢？

### 1.2 系统调用和内核状态切换：
既然用户程序只能运行到用户空间，那么当用户程序需要使用涉及到系统管理资源的时候该如何操作。答案就是交给操作系统代理处理，方式就是通过系统调用。
> - 用户空间访问内核空间的唯一方式就是系统调用：通过这个统一入口接口，所有的资源访问都是在内核程序的控制下执行，以免导致用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。
> - 当用户进程执行系统调用而陷入内核代码中执行时，就称进程处于内核运行态，此时处理器处于特权级最高的(0级)。
> - 当用户进程在执行自己的代码时，则称其处于用户运行态，此时处理器在特权级最低的(3级)。
> - 处理器在特权等级高的时候才能执行那些特权CPU指令。

也就是说，虽然用户进程之间是相互独立的，但它们却是共享一份内核空间。

### 1.3 linux的用户程序和进程：

#### 1.3.1 用户程序和进程：
和windows中区分的进程和线程不同，在linux中，所有的用户程序执行时状态都是进程，所谓运行时表示进程的概念只在内存中存在，也就是说进程是静态程序的运行时状态。
进程间存在父子关系来表示同一个用户程序开启的多个同步任务，并且整个系统存在完整的进程树关系，可以通过命令 *pstree* 查看。
通过 pstree 可以看到，所有的进程也构成一个以 init 为根的树状结构，这是因为 Linux kernel 并不提供直接建立新进程的系统调用。剩下的所有进程都是 init 进程通过 fork 机制建立的。新的进程要通过老的进程复制自身得到，这就是 fork。fork 是一个系统调用。
每个进程都在内存中分配有属于自己的一片空间 (内存空间，包含栈、堆、全局静态区、文本常量区、程序代码区)。当一个程序调用 fork 的时候，实际上就是将上面的内存空间，又复制出来一个，构成一个新的进程，并在内核中为该进程创建新的附加信息 (比如新的 PID，而 PPID 为原进程的 PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的指令…)。我们只能通过进程的附加信息来区分两者。
程序调用 exec 的时候，进程清空自身的内存空间，并根据新的程序文件重建程序代码、文本常量、全局静态、堆和栈(此时堆和栈大小都为 0)，并开始运行。
这种进程之间相互隔离资源，是现代操作系统的主要特点。这种隔离的提出是因为：
> - 进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。
> - 进程隔离技术使用了虚拟地址空间，即进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。

#### 1.3.2 进程间通信目的：
进程之间为什么需要进行通信，主要目的还是为了进行交互来更好的完成用户指定的任务，提升效率。所以主要目的有以下几个方面：

1 数据传输
  > 一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几M字节之间

2 共享数据
  > 多个进程想要操作共享数据，一个进程对共享数据

3 通知事
  > 一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。

4 资源共享
  > 多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。

5 进程控制
  > 有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

#### 1.3.3 进程间通信方式（IPC）：
既然进程之间已经被隔离开，那么直接的通信方式是无法实现的。虽然用户进程之间是相互独立的，但它们却是共享一份内核空间。很显然，当一个用户进程想与另外一个用户进程进行通信时，就可以通过内核空间来完成了。
linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。
而对Unix发展做出重大贡献的两大主力AT&T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“system V IPC”，通信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。
> UNIX进程间通信方式包括：管道、FIFO、信号；
> System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存；
> POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存。

Linux将上述所有的通信方式继承下来。由于Unix版本的多样性，电子电气工程协会（IEEE）开发了一个独立的Unix标准，这个新的ANSI Unix标准被称为计算机环境的可移植性操作系统界面（PSOIX）。现有大部分Unix和流行版本都是遵循POSIX标准的，而Linux从一开始就遵循POSIX标准；所以主要分析linux的Posix API所提供的进程间通信方式：
> 1.管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
> 2.信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
> 3.报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
> 4.共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
> 5.信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
> 6.套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。


## 2  google新增的进程间通信内核模块binder：

google针对移动应用的特点提出了特殊的进程间通信要求，并且对GUN/Linux内核进行了修改，新增了 *binder* 模块，定制后的linux内核代码由google进行维护，可以通过 *[官方网站](https://android.googlesource.com/kernel)* 来查看具体的提交内容。
新增代码的实现位于../drivers/staging/android/binder.c，依赖于文件../drivers/staging/android/binder.h。一般来说编译之后的内核中的 /dev/binder 就是 binder 的设备文件，可以使用 *adb shell* 进入当前手机，查看/dev/文件夹下的内容找到binder设备文件。
然后在 android framework 中通过这个驱动在 native 层包装了一套 C/S 架构的框架出来，最后在 java 对应也封装了一层供 android 上层app调用完成应用程序之间的通信。

### 2.1 进程间通信的总体思路：
按照上一节的分析，进程间通信的总体过程为：
> 进程A发起请求给内核里的程序，内核里的程序再将请求转发给进程B，从而达到进程间通信。

其中内核中的程序就可以有很多的选组了，上述 Posix API 所提供的所有系统调用都可以使用。

### 2.2 内核模块的动态加载技术：
linux内核作为一个分布式维护的开源内核，提供了良好的扩展和定制能力。新增内核模块是一个非常有用的技术。
-  Linux的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题：
   -  模块是具有独立功能的程序，可以被单独编译，但不能独立运行。
   -  它在运行时被链接到内核作为内核的一部分在内核空间运行。
-  这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。
   -  这个运行在内核空间的、负责各个用户进程通信的内核模块，就是我们后面要涉及到的：Binder驱动。
也就是说，google通过新增内核模块完成了进程间通信协议的实现，然后使用binder驱动来调用这个新增的内核模块，来为上层应用提供接口，最后在framework层封装这个接口来提供 java API 调用接口。

### 2.3 为什么需要再实现一个进程间通信协议：
既然linux kernel已经提供了这么多的IPC方式，为什么还需要再实现一个？根据 binder的[wiki](http://elinux.org/Android_Binder) ，主要原因在于两点：
> avoiding copies by having the kernel copy from the writer into a ring buffer in the reader's address space directly (allocating space if necessary)
> managing the lifespan of proxied remoted userspace objects that can be shared and passed between processes (upon which the userspace binder library builds its remote reference counting model)

也就是说，之前提供的IPC方式并没有
