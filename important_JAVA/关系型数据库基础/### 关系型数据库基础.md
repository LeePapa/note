### 关系型数据库基础：


#### 存储过程:
存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
[]()
[]()
[]()
[]()
[]()
[]()
[]()
[]()
[]()
[]()

#### 数据库事务：

##### 什么是数据库事务：
[彻底理解数据库事务](http://www.hollischuang.com/archives/898)

事务(Transaction)，一般是指要做的或所做的事情。
数据库事务（Database Transaction），通常包含对数据库进行读或写的一个操作序列，是指作为单个逻辑工作单元执行的一系列操作。它的存在包含有以下两个目的：
（1）为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
（2）当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

所以说，数据库事务更多的是语义上的约束，要么完全地执行，要么完全地不执行。可以把事务看作一组数据库操作动作的集合，这一组动作的集合在语义上有具体的要求，这些要求抽象出来，也就是所谓的事务的四个特性：
（1）原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
（2）一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
（3）隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
（4）持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。
一致性与原子性是密切相关的，原子性的破坏可能导致数据库的不一致，但是一致性是从业务逻辑角度来保证的数据正确性。可以认为一致性的前提是原子性，否则无从谈起一致性的状态切换。

事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。

##### 什么是数据库的隔离级别：
[深入分析事务的隔离级别](http://www.hollischuang.com/archives/943)
[乐观锁与悲观锁的区别](http://www.cnblogs.com/Bob-FD/p/3352216.html)
[深入理解乐观锁与悲观锁](http://www.hollischuang.com/archives/934)

在DBMS中，事务保证了一个操作序列可以全部都执行或者全部都不执行（原子性），从一个状态转变到另外一个状态（一致性）。由于事务满足持久性，所以一旦事务被提交之后，数据就能够被持久化下来。又因为事务是满足隔离性的，所以，当多个事务同时处理同一个数据的时候，多个事务直接是互不影响的，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生脏读、不可重复读或者幻读等读现象。

在数据库事务的ACID四个属性中，隔离性是一个最常放松的一个。可以在数据操作过程中利用数据库的锁机制或者多版本并发控制机制获取更高的隔离等级。但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。

在软件开发中，几乎每类这样的问题都会有多种最佳实践来供我们参考，很多DBMS定义了多个不同的“事务隔离等级”来控制锁的程度和并发能力。
ANSI/ISO SQL定义的标准隔离级别有四种，从高到底依次为：
可序列化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。

###### 未提交读(Read uncommitted)：
最低的隔离级别，在这种事务隔离级别下，一个事务可以读到另外一个事务未提交的数据。
出现未提交读的数据库锁情况有：
（1）事务在读数据的时候并未对数据加锁。
（2）务在修改数据的时候只对数据增加行级共享锁。

现象：
（1）事务1读取某行记录时，事务2也能对这行记录进行读取、更新（因为事务一并未对数据增加任何锁）；
（2）当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本（因为事务二只增加了共享读锁，事务一可以再增加共享读锁读取数据），即使该修改尚未被提交；
（3）事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（因为事务一对数据增加了共享读锁，事务二不能增加排他写锁进行数据的修改）；
所以：未提交读会导致脏读。

###### 提交读(Read committed)：
即：读已提交，通过名字也可以分析出，在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。

提交读的数据库锁情况：
（1）事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
（2）事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

现象：
（1）事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）；
（2）事务1读取某行的一瞬间，事务2不能修改该行数据，但是，只要事务1读取完改行数据，事务2就可以对该行数据进行修改。（事务一在读取的一瞬间会对数据增加共享锁，任何其他事务都不能对该行数据增加排他锁。但是事务一只要读完该行数据，就会释放行级共享锁，一旦锁释放，事务二就可以对数据增加排他锁并修改数据）；
（3）事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。

在提交读隔离级别中：事务一在更新数据的时候，会对该行数据增加排他锁，直到事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。只有在事务二提交之后，事务一才能读数据。
所以，提交读可以解决脏读的现象。
但是，事务一两次读取的结果并不一致，所以提交读不能解决不可重复读的读现象。
提交读这种隔离级别保证了读到的任何数据都是提交的数据，避免了脏读(dirty reads)。但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。

###### 可重复读(Repeatable reads)：
由于提交读隔离级别会产生不可重复读的读现象。所以，比提交读更高一个级别的隔离级别就可以解决不可重复读的问题。这就是可重复读隔离级别。

可重复读的数据库锁情况：
（1）事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；
（2）事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

现象：
（1）事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）。
（2）事务1在读取某行记录的整个过程中，事务2都不能修改该行数据（事务一在读取的整个过程会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，任何其他事务都不能对该行数据增加排他锁。所以，可重复读能够解决不可重复读的读现象）
（3）事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）

只有在事务一提交之后，事务二才能更改该行数据。所以，只要在事务一从开始到结束的这段时间内，无论他读取该行数据多少次，结果都是一样的。
可重复读隔离级别可以解决不可重复读的读现象。但是可重复读这种隔离级别中，还有另外一种读现象他解决不了，那就是幻读。看下面的例子：
事务1执行：SELECT * FROM users WHERE age BETWEEN 10 AND 30;
事务2执行：
        INSERT INTO users VALUES ( 3, 'Bob', 27 );
        COMMIT;
事务1执行：SELECT * FROM users WHERE age BETWEEN 10 AND 30;

上面的两个事务执行情况及现象如下：
（1）事务一的第一次查询条件是age BETWEEN 10 AND 30;如果这是有十条记录符合条件。这时，他会给符合条件的这十条记录增加行级共享锁。任何其他事务无法更改这十条记录。
（2）事务二执行一条sql语句，语句的内容是向表中插入一条数据。因为此时没有任何事务对表增加表级锁，所以，该操作可以顺利执行。
（3）事务一再次执行SELECT * FROM users WHERE age BETWEEN 10 AND 30;时，结果返回的记录变成了十一条，比刚刚增加了一条，增加的这条正是事务二刚刚插入的那条。
所以，事务一的两次范围查询结果并不相同。这也就是我们提到的幻读。

###### 可序列化(Serializable)：
可序列化(Serializable)是最高的隔离级别，前面提到的所有的隔离级别都无法解决的幻读，在可序列化的隔离级别中可以解决。
产生幻读的原因是事务一在进行范围查询的时候没有增加范围锁(range-locks：给SELECT 的查询中使用一个“WHERE”子句描述范围加锁），所以导致幻读。

可序列化的数据库锁情况：
（1）事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；
（2）事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

现象：
（1）事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。(因为事务一对表增加了表级共享锁，其他事务只能增加共享锁读取数据，不能进行其他任何操作）
（2）事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。（事务一对表增加了表级排他锁，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作）

虽然可序列化解决了脏读、不可重复读、幻读等读现象。但是序列化事务会产生以下效果：
（1）无法读取其它事务已修改但未提交的记录。
（2）在当前事务完成之前，其它事务不能修改目前事务已读取的记录。
（3）在当前事务完成之前，其它事务所插入的新记录，其索引键值不能在当前事务的任何语句所读取的索引键范围中。

###### 总结：
四种事务隔离级别从隔离程度上越来越高，但同时在并发性上也就越来越低。之所以有这么几种隔离级别，就是为了方便开发人员在开发过程中根据业务需要选择最合适的隔离级别。


##### 悲观锁和乐观锁：
上述隔离级别对于并发的影响非常大：
放在一个表上的锁限制对整个表的并发访问；放在数据页上的锁限制了对整个数据页的访问；放在行上的锁只限制对该行的并发访问。可见行锁粒度最小，并发访问最好，页锁粒度最大，表锁介于2者之间。

通常控制并发访问的时候加锁策略有：
（1）悲观锁（Pessimistic Concurrency Control）：也叫做悲观并发控制，假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
（2）乐观锁（Optimistic Concurrency Control）：也叫做乐观并发控制，假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题，所以在乐观锁环境中，会增加并发用户读取对象的次数。

不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。上述两种只是枷锁的策略方式，而不是技术方式。

从数据库厂商的角度看，使用乐观的页锁是比较好的，尤其在影响很多行的批量操作中可以放比较少的锁，从而降低对资源的需求提高数据库的性能。再考虑聚集索引。在数据库中记录是按照聚集索引的物理顺序存放的。如果使用页锁，当两个用户同时访问更改位于同一数据页上的相邻两行时，其中一个用户必须等待另一个用户释放锁，这会明显地降低系统的性能。interbase和大多数关系数据库一样，采用的是乐观锁，而且读锁是共享的，写锁是排他的。可以在一个读锁上再放置读锁，但不能再放置写锁；你不能在写锁上再放置任何锁。锁是目前解决多用户并发访问的有效手段。  

###### MySQL InnoDB中使用悲观锁：
要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;

```SQL
//0.开始事务
begin;/begin work;/start transaction; (三者选一就可以)
//1.查询出商品信息
select status from t_goods where id=1 for update;
//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);
//3.修改商品status为2
update t_goods set status=2;
//4.提交事务
commit;/commit work;
```
上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。
上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。




因为数据库自动完成了数据库事务的物理完整性，我们更应该关注在什么情况下使用数据库事务、事务对性能的影响，如何使用事务等等。

其中最需要注意的是隔离性：

===============================================================================================================
隔离级别                    脏读（Dirty Read）      不可重复读（NonRepeatable Read）       幻读（Phantom Read） 
===============================================================================================================

未提交读（Read uncommitted）  可能                      可能                                   可能

已提交读（Read committed）    不可能                     可能                                  可能

可重复读（Repeatable read）   不可能                     不可能                                 可能

可串行化（Serializable ）     不可能                     不可能                                 不可能
===============================================================================================================



[数据库事务](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1)
[MySQL 四种事务隔离级的说明](http://www.cnblogs.com/zhoujinyi/p/3437475.html)

[]()
[]()
[]()
[]()
[]()
[]()
[]()