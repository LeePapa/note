关于android的一些折腾：

（0）红米note3高配全网通使用：
1 首先进入fastboot使用官方的线刷包进行完整的系统安装和重置；
2 然后再次进入fastboot进行官方解锁，这样就可以开启root权限，并且可以为后续的system分区读写做准备；
3 进入系统后打开adb调试功能，对system解锁：adb root; adb disable-verity; adb reboot，重启后获取到完整的root权限；
	ps:或者直接在安全中心中打算root，miui系统会自动下载root包进行重启，重启完毕之后获取root权限。
4 刷入第三方recovery：进入fastboot，然后输入：fastboot flash recovery recovery.img，成功后进入recovery进行基本操作，例如备份；
5 重新进入fastboot进行解锁，然后进入recovery刷入第三方rom，因为第三方rom会改变system的内容，所以需要重新解锁。
到这儿就完成了整个刷机过程。第三方固件需要注意底层不同会带来不同的问题，需要谨慎。

（1）在自己安装busybox之后手动删除/system/xbin的所有内容，然后无法获取app的root之后的恢复方法：
<1>关于root的一些基本概念：
root对于android来说非常重要，因为很多定制系统的操作是需要依赖于root权限进行的。使用了root才能充分的享受android带来的自由。
参考：
http://stackoverflow.com/questions/33624228/does-deleting-system-xbin-su-prevent-root-access
内容如下：
You are mixing two type of roots.
The root you are getting from adb is calld unsecure boot, or debuggable kernel option. This is set inside the default.prop file in the ramdisk, and used in the adbd binary.
The /system/xbin/su is just a root elevation binary which in your version also has the right configuration in SE-Policy. Just deleting it will deny root for all the apps, but not for you when you debug using ADB.
If you want to disable root for yourself in adb, you can just compile as 'user' instead of userdebug or hack into the /system/core/adb binary.
<2>恢复/system/xbin/文件夹内容：
手动使用adb的shell获取su，并且重新remount rw也失败之后，重新进入recovery，然后挂载/system路径，进行文件操作，将之前的/system/xbin/su文件恢复，然后权限修改为0755，重新开机，就可以获取app的su了，然后重新安装busybox，并且建立连接，方便使用。

（2）andorid上使用linux系统：
<0>总体思路：
安卓手机启动的过程： 上电>>arm芯片调入boot的程序执行>>调用内核执行>>打开android虚拟机
所以把android手机改为嵌入式linux的方法就是：内核启动后调用自己做的文件系统，这里可以是qt等小巧的文件系统，也可以是ubuntu，debian等文件系统，也可以按自己的需求制作文件系统来进行加载。
几个关键点：
一、知道Boot怎么去调用内核，用的是什么boot程序。
二、要有内核源码，编译自己的内核，有内核源码才值得玩，内核编译好后一般只有几M大小；
三、要知道内核怎么调用文件系统，一般是一个脚本
关于内核源码，关键的还是各个模块的驱动，很多产商只提供ko文件，并不提供源码，这就不好玩了。所以手机最好选大厂商的，这些厂家公布的源码相对完善一些。
目前已经可以用的有：https://github.com/automateljw/c8812 ，这个项目提供了C8812的基本引导。
参考文档：https://www.embbnux.com/2014/03/31/android_to_embeded_linux_board/
<1>共生安装方式：
如果不想破坏原来的安卓系统，用下面两个方法体验和使用Linux桌面比较好：
1. 直接安装Linux到SD卡上。这种情况是运行一个完整的Linux版本。可以使用别人构建好的镜像，一句dd if=xxxx.img of=/dev/sdX命令，就可以安装Linux系统到sd卡。然后根据制造商的不同，关机使用不同的按键组合就能从SD引导运行这个Linux系统。但是这种镜像要有针对你的手机或平板的驱动，你才能用一些功能，比如说最基本的lcd屏要能显示、触摸屏至少要能用吧。

2. 在安卓系统之上，利用安卓本身的Linux内核、服务和应用程序来运行Linux桌面。基本的原理都是chroot。但在使用图形界面这一块，有些不同：
2.1 用的最多的是VNC，在Linux系统里运行一个VNC服务器，然后用安卓下的VNC客户端连接就可以了。但是这种方法在配置一般的手机或平板上运行不流畅。
2.2 也可以使用Xserver应用（还没有Wayland或Mir），这比起VNC的速度比较慢的协议来说，效率要高一些，但是目前的Xserver基本不实用：http://blog.sina.com.cn/s/blog_59cf67260101bvjf.html。
2.3. 关掉安卓服务，直接运行原生的Xorg，在这基础之上运行Linux桌面。 
运行原生的Xorg有以下好处：
a. 比VNC：流畅。我的全志A10单核1.0GHz的机器，基本上有我原来那个赛扬的老机器用Windows XP的流畅度了。
b. 比TF卡：方便。不用重启机器，按各种按钮，就能切换到各种Linux桌面。
c. 比TF卡：方便。同上，玩完Linux，不用重启机器，就可以重新回到安卓。当然，这一点比VNC要差一点，这是由于没有人开发比较完整的Xserver。（或者Wayland、Mir也行啊）。
d. 比TF卡：还是方便。能直接用安卓下的驱动，不用从源码编译驱动。
e. 就和虚拟机一样，可以无痛的体验任何linux系统，只要有它的rootfs就行了。
<2>介绍linuxdeploy：
linuxdeploy是俄国老毛子大神meefik开发的，官方网站是：https://github.com/meefik/linuxdeploy，上面安装busybox也是用的他的：https://github.com/meefik/busybox
linuxdeploy总体上的思路就是和<1>中所述基本相同，实现的本质上是chroot 和 mount，所以安装的linux系统需要和自己的手机的CPU架构相符合，并且有足够的空间来进行放置img镜像。
这样就可以简单的通过文件来进行恢复和操作系统的切换了，只要android系统还在运行，就可以mount和unmount不同的操作系统来玩了。
参考文档：http://forum.ubuntu.org.cn/viewtopic.php?f=177&t=450030
<3>安装linuxdeploy：
参考教程：
http://blog.csdn.net/leekwen/article/details/45093093
http://www.oneplusbbs.com/thread-628385-1-1.html
https://www.kali.org/tutorials/kali-linux-android-linux-deploy/
http://forum.ubuntu.org.cn/viewtopic.php?t=463818
http://www.freebuf.com/articles/terminal/13209.html
http://tieba.baidu.com/p/3310711970
http://tieba.baidu.com/p/4212305788
另一种方式：
http://forum.ubuntu.org.cn/viewtopic.php?t=451917
<4>原理描述：
基本就是创建一个img的映像文件，然后联网获取对应系统的rootfs些到这个镜像中，然后chroot这个img就可以启动这个linux系统了。
这样所依赖的内核还是基本的android内核，
<5>备份和还原：
备份和还原一直都是linux系统的关键。linuxdeploy支持导出rootfs的tar包，并且可以通过对img和配置文件的备份来起到完整备份作用。

（3）在linuxdeploy中使用ubuntu：
<1>安装中文字体：
进入ssh：
输入用户名和密码changme
安装中文字体：
cd /home/wentao
wget http://jaist.dl.sourceforge.net/project/wqy/wqy-microhei/0.2.0-beta/wqy-microhei-0.2.0-beta.tar.gz
tar -xvf wqy-microhei-0.2.0-beta.tar.gz -C /home/wentao
sudo mv wqy-microhei /usr/share/fonts/
sudo chmod 555 /usr/share/fonts/wqy-microhei/*
cd /usr/share/fonts/wqy-microhei/ 
sudo mkfontscale 
sudo mkfontdir 
sudo fc-cache -fv
这样进入vnc之后就可以看到中文了。
<2>安装基本的docker支持：
sudo apt-get install docker.io
因为性能问题，只能保证可以用，不建议使用。
<3>安装jdk环境：
因为是arm64位架构，所以使用的jdk也需要适配这个版本：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
选择Linux ARM 64 Hard Float ABI
将下载的包拷贝到手机内置的sdcard中，然后进入ssh进行解压缩和安装：
tar -xvf /mnt/0/jdk.tar.gz -C /usr/local/bin
然后设置环境变量：
nano /etc/profile
添加以下内容：
export JAVA_HOME=/usr/local/bin/jdk1.8.0_101
export CLASSPATH=.:$CLASSPTAH:$JAVA_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin
生效：
source /etc/profile
检查：
java -version
返回：
java version "1.8.0_101"
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
表示当前已经安装成功了。
随着Oracle官方的Oracle Java 7 JDK (硬件浮点)支持被加入，现在ARM平台可以直接用官方的JDK了。
参考：http://blog.csdn.net/mirkerson/article/details/8082065/
<4>安装javaIDE：


参考文档：http://blog.csdn.net/mirkerson/article/details/8082065/

（4）android学习：
<0>开发环境：
使用centos7_X64版本来进行开发，并且使用docker来隔离开发环境。
首先安装系统基本的开发环境：
yum groupinstall "Development Tools"
或者选择安装最小开发环境：
yum install -y gcc g++ kernel-devel make git
参考文档：http://www.diogogmt.com/2015/09/19/installing-build-essentials-on-centos-7-and-ubuntu-14-03/

<1>设置系统代理：
开发android，那么代理必不可少，可以使用系统代理来进行设置：


<1>android内核与GUN/linux内核的区别：
android虽然基于linux，但是他不同于kernel.org所维护的linux内核上建立的完整的linux系统，并且在内核上还进行了定制，主要在于驱动上，并且根据手机端的特性对电源管理等进行了修改。也正因为驱动的原因，android被从linux树种移除了。
既然android还是基于linux的内核，并且有所不同，那么就一定要仔细分析差异，然后对比学习。
细节参考：http://www.cnblogs.com/manuosex/p/3590207.html
概述参考：
http://blog.csdn.net/juana1/article/details/6648518
http://tech.it168.com/a2011/0725/1222/000001222793.shtml
<2>应用开发之间的差异：
那么是不是除去驱动在两者之间分别为：编译好的.ko文件和开放源代码之间的差异，就没有什么不同？并不是，除了驱动的不同，两者在linux内核基础上使用的C库也不一样。
传统的linux系统中的程序基本都依赖于GNU C Library (glibc)，google自己打造了一个C的运行时库，称为Bionic Library (bionic)。
因为google的官方Toolchain也是基于Bionic Libc而并非glibc的。这使得使用或移植其他Toolchain来用于Android要比较麻烦：在Google公布用于Android的官方Toolchain之前，多数的Android爱好者使用的Toolchain是在http://www.codesourcery.com/gnu_toolchains/arm/download.html 下载的一个通用的Toolchain，它用来编译和移植Android 的Linux内核是可行的，因为内核并不需要C库，但是开发Android的应用程序时，直接采用或者移植其他的Toolchain都比较麻烦，其他Toolchain编译的应用程序只能采用静态编译的方式才能运行于Android模拟器中，这显然是实际开发中所不能接受的方式。目前尚没有看到说明成功移植其他交叉编译器来编译Android应用程序的资料。
与glibc相比，Bionic Libc有如下一些特点：
- 采用BSD License，而不是glibc的GPL License； 
- 大小只有大约200k，比glibc差不多小一半，且比glibc更快； 
- 实现了一个更小、更快的pthread； 
- 提供了一些Android所需要的重要函数，如”getprop”, “LOGI”等； 
- 不完全支持POSIX标准，比如C++ exceptions，wide chars等； 
- 不提供libthread_db 和 libm的实现 
另外，Android中所用的其他一些二进制工具也比较特殊：
- 加载动态库时使用的是/system/bin/linker而不是常用的/lib/ld.so; 
- prelink工具不是常用的prelink而是apriori，其源代码位于” <your_android>/build/tools/apriori” 
- strip工具也没有采用常用的strip，即“<your_android>/prebuilt/linux-x86/toolchain/arm-eabi-4.2.1/bin”目录下的arm-eabi-strip，而是位于<your_android>/out/host/linux-x86/bin/的soslim工具。
Bionic的官方git地址为：
https://android.googlesource.com/platform/bionic/
github镜像地址为：
https://github.com/android/platform_bionic

细节参考：
http://blog.csdn.net/andyhuabing/article/details/7183369
http://blog.csdn.net/gzzaigcnforever/article/details/7480101


（）android内核编译：
作为整个android的底层，内核提供了对整体硬件的控制和性能的限制，很多开源硬件运行用户自定义内核来达到某些特殊需求，作为基本的geek，编译和定制内核是必须的。现在进入android内核的编译环节，这部分最大的不同在于交叉编译器的使用。
1 初始环境设置和工具链安装：
因为android也是属于linux内核的一种，只需要编译内核而不需要依赖别的组件，所以对toolchain(NDK)的选择上宽松得多。大体来讲有这样几种可能性：自己编译arm-eabi的gcc toolchain，使用Sourcery的toolchain，使用Google提供的NDK构建toolchain，或者使用第三方（比如crystax）修改过的NDK。
<0>系统初始环境设置：
首先系统必须安装有基本的编译环境：
yum -y install gcc make git
<1>通用交叉编译环境：
需要安装交叉编译环境才能在PC端进行嵌入式的开发，所以需要这个基本环境。然而centos官方源中并不支持这个程序，所以需要安装第三方源：
安装EPEL源：
rpm -ivh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-7.noarch.rpm
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
检查是否安装成功：
yum repolist
查看某个包的详细信息：
yum --enablerepo=epel info htop
列出epel源的所有包列表：
yum --disablerepo="*" --enablerepo="epel" list available | less
然后安装交叉编译器：
yum -y install gcc-arm-linux-gnu
检查是否安装成功：
arm-linux-gnu-gcc --version
回显：
arm-linux-gnu-gcc (GCC) 4.8.1 20130717 (Red Hat 4.8.1-5)
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
表示已经安装成功。
参考文档：
http://www.ha97.com/5649.html
https://pkgs.org/centos-7/epel-x86_64/gcc-arm-linux-gnu-4.8.1-5.2.el7.1.x86_64.rpm.html
<2>从googleNDK获取开发工具：
编译android相关的内容，最好使用google提供的工具链，包括编译内核，可以减少不必要的麻烦。官方下载地址为：https://developer.android.com/ndk/downloads/index.html
例如下载：android-ndk-r12b-linux-x86_64.zip
下载之后根据当前的系统，在压缩包的toolchains目录下选择对应的包，解压到某一个目录中，然后将这个目录添加到系统环境变量中。
$export PATH=$PATH:/myandroid/androidsrc/prebuilt/linux-x86/toolchain/arm-eabi-4.2.1/bin
<3>从google官方工具库获取：
从官方维护网站：https://android.googlesource.com/platform/prebuilts/gcc/
下载对应版本的工具链，然后安装：
git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9
安装方法同上。
<4>第三方修改的工具链：
和上面类似，需要手动安装并且添加到环境变量中去。关键就是选取的第三方工具链的来源。

2 内核代码编译：
作为linux系统的核心，内核就是根本，之前的linuxDeploy也是利用了已经提供支持的内核才得以跑起来。
针对android手机的内核编译，因为驱动的原因，尽量选择出货量大的，大型公司的产品，支持和开源会做的好一点。
<1>nexus 5内核编译：
作为官方亲儿子，编译内核方面还是有足够的支持的，并且初学编译内核，使用亲儿子可以减少干扰，降低编译难度。
参考文档：http://www.roboby.com/android%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3.html
操作系统为ubuntu14.04_X64
sudo apt-get install gcc make git libncurses5-dev
下载boot.img打包程序：
git clone https://github.com/pbatard/bootimg-tools.git
cd bootimg-tools/
make
cd cpio/
gcc mkbootfs.c  -o mkbootfs -I../include
cd ../..
mkdir andorid_boot_tools_bin
cd andorid_boot_tools_bin/
cp ../bootimg-tools/mkbootimg/mkbootimg .
cp ../bootimg-tools/mkbootimg/unmkbootimg .
cp ../bootimg-tools/cpio/mkbootfs .
cd ..
这样就在bootimg-tools文件夹中生成了构建boot镜像的可执行文件。

准备编译环境设置脚本：
nano run_this_android.sh
内容如下：
{
# 设置交叉编译器位置
export CC=$(pwd)/arm-eabi-4.7/bin/arm-eabi-
export CROSS_COMPILE=$(pwd)/arm-eabi-4.7/bin/arm-eabi-
# 设置编译内核架构
export ARCH=arm
export SUBARCH=arm
# 设置boot.img生成工具
export PATH=$PATH:$(pwd)/andorid_boot_tools_bin
}
然后设置为可执行，然后再当前终端中生效：
chmod +x run_this_android.sh
source run_this_android.sh

设置交叉编译器的权限（这一步非常关键）：
从官方下载下来的工具的权限是有问题的，所以一定要对交叉编译器目录进行整体的权限设置：
chmod -R +x arm-eabi-4.7/
然后对其中的bin目录设置为755权限：
chmod -R 755 bin/*
（之前没有这样设置，会有各种编译的权限问题，并且造成无法写入的错误）

完成基本环境设置之后，在官方内核代码页面找到代码同步目录：
http://source.android.com/source/building-kernels.html#figuring-out-which-kernel-to-build
选择：
Device		Binary location					Source location		Build configuration
hammerhead	device/lge/hammerhead-kernel	kernel/msm			hammerhead_defconfig
确定git路径：
git clone https://android.googlesource.com/kernel/msm
挂载代理下载完整的代码。
然后查看当前代码树的分支：
git branch -r
显示结果为：
{
origin/HEAD -> origin/master
  origin/android-msm-2.6.35
  origin/android-msm-3.9-usb-and-mmc-hacks
  origin/android-msm-angler-3.10-marshmallow-dr
  origin/android-msm-angler-3.10-marshmallow-dr1.5
  origin/android-msm-angler-3.10-marshmallow-dr1.6
  origin/android-msm-angler-3.10-marshmallow-dr1.6-1
  origin/android-msm-angler-3.10-marshmallow-mr1
  origin/android-msm-angler-3.10-n-preview-1
  origin/android-msm-angler-3.10-n-preview-2
  origin/android-msm-angler-3.10-n-preview-3
  origin/android-msm-angler-3.10-n-preview-4
  origin/android-msm-angler-3.10-n-preview-5
  origin/android-msm-anthias-3.10-lollipop-mr1-wear-release
  origin/android-msm-anthias-3.10-lollipop-wear-release
  origin/android-msm-anthias-3.10-marshmallow-mr1-wear-release
  origin/android-msm-asus-3.10-lollipop-mr1-wear-release
  origin/android-msm-asus-3.10-marshmallow-mr1-wear-release
  origin/android-msm-bass-3.10-lollipop-mr1-wear-release
  origin/android-msm-bass-3.10-marshmallow-mr1-wear-release
  origin/android-msm-bullhead-3.10-marshmallow-dr
  origin/android-msm-bullhead-3.10-marshmallow-dr-0
  origin/android-msm-bullhead-3.10-marshmallow-dr1.5
  origin/android-msm-bullhead-3.10-marshmallow-dr1.6
  origin/android-msm-bullhead-3.10-marshmallow-mr1
  origin/android-msm-bullhead-3.10-marshmallow-mr1-eas
  origin/android-msm-bullhead-3.10-marshmallow-mr2
  origin/android-msm-bullhead-3.10-n-preview-1
  origin/android-msm-bullhead-3.10-n-preview-2
  origin/android-msm-bullhead-3.10-n-preview-3
  origin/android-msm-bullhead-3.10-n-preview-4
  origin/android-msm-bullhead-3.10-n-preview-5
  origin/android-msm-dory-3.10-kitkat-wear
  origin/android-msm-dory-3.10-lollipop-mr1-wear-release
  origin/android-msm-dory-3.10-lollipop-wear-release
  origin/android-msm-dory-3.10-marshmallow-mr1-wear-release
  origin/android-msm-flo-3.4-jb-mr2
  origin/android-msm-flo-3.4-kitkat-mr0
  origin/android-msm-flo-3.4-kitkat-mr1
  origin/android-msm-flo-3.4-kitkat-mr2
  origin/android-msm-flo-3.4-l-preview
  origin/android-msm-flo-3.4-lollipop-mr1
  origin/android-msm-flo-3.4-lollipop-mr1.1
  origin/android-msm-flo-3.4-lollipop-mr1.2
  origin/android-msm-flo-3.4-lollipop-release
  origin/android-msm-flo-3.4-marshmallow
  origin/android-msm-flo-3.4-marshmallow-mr1
  origin/android-msm-flo-3.4-marshmallow-mr2
  origin/android-msm-hammerhead-3.4-kitkat-mr1
  origin/android-msm-hammerhead-3.4-kitkat-mr2
  origin/android-msm-hammerhead-3.4-kk-fr1
  origin/android-msm-hammerhead-3.4-kk-fr2
  origin/android-msm-hammerhead-3.4-kk-r1
  origin/android-msm-hammerhead-3.4-l-preview
  origin/android-msm-hammerhead-3.4-lollipop-mr1
  origin/android-msm-hammerhead-3.4-lollipop-mr1.1
  origin/android-msm-hammerhead-3.4-lollipop-release
  origin/android-msm-hammerhead-3.4-m-preview
  origin/android-msm-hammerhead-3.4-marshmallow
  origin/android-msm-hammerhead-3.4-marshmallow-mr1
  origin/android-msm-hammerhead-3.4-marshmallow-mr2
  origin/android-msm-huawei-3.10-lollipop-mr1-wear-release
  origin/android-msm-huawei-3.10-lollipop-mr1-wear-release-1
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release-1
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release-2
  origin/android-msm-lego-3.10-marshmallow-dr
  origin/android-msm-lenok-3.10-kitkat-wear
  origin/android-msm-lenok-3.10-lollipop-mr1-wear-release
  origin/android-msm-lenok-3.10-lollipop-wear-release
  origin/android-msm-lenok-3.10-marshmallow-mr1-wear-release
  origin/android-msm-mako-3.4-jb-mr1
  origin/android-msm-mako-3.4-jb-mr1-fr
  origin/android-msm-mako-3.4-jb-mr1-kgsl
  origin/android-msm-mako-3.4-jb-mr1.1
  origin/android-msm-mako-3.4-jb-mr2
  origin/android-msm-mako-3.4-kitkat-mr0
  origin/android-msm-mako-3.4-kitkat-mr1
  origin/android-msm-mako-3.4-kitkat-mr2
  origin/android-msm-mako-3.4-lollipop-mr1
  origin/android-msm-mako-3.4-lollipop-mr1.1
  origin/android-msm-mako-3.4-lollipop-release
  origin/android-msm-moto-3.10-lollipop-mr1-wear-release
  origin/android-msm-nemo-3.10-marshmallow-mr1-wear-release
  origin/android-msm-nemo-3.10-n-preview-1-wear-release
  origin/android-msm-nemo-3.10-n-preview-2-wear-release
  origin/android-msm-seed-3.10-lollipop-mr1
  origin/android-msm-seed-3.10-marshmallow
  origin/android-msm-seed-3.10-marshmallow-mr1
  origin/android-msm-seed-3.10-marshmallow-mr2
  origin/android-msm-seed-3.10-n-preview-2
  origin/android-msm-seed-3.10-n-preview-3
  origin/android-msm-seed-3.10-n-preview-4
  origin/android-msm-seed-3.10-n-preview-5
  origin/android-msm-shamu-3.10-lollipop-mr1
  origin/android-msm-shamu-3.10-lollipop-release
  origin/android-msm-shamu-3.10-m-preview
  origin/android-msm-shamu-3.10-marshmallow
  origin/android-msm-shamu-3.10-marshmallow-mr1
  origin/android-msm-shamu-3.10-marshmallow-mr1-r0.15
  origin/android-msm-shamu-3.10-marshmallow-mr2
  origin/android-msm-shamu-3.10-n-preview-1
  origin/android-msm-shamu-3.10-n-preview-2
  origin/android-msm-shamu-3.10-n-preview-3
  origin/android-msm-shamu-3.10-n-preview-4
  origin/android-msm-shamu-3.10-n-preview-5
  origin/android-msm-smelt-3.10-lollipop-mr1-wear-release
  origin/android-msm-smelt-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sony-cm-jb-3.0
  origin/android-msm-sparrow-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sprat-3.10-kitkat-wear
  origin/android-msm-sprat-3.10-lollipop-mr1-wear-release
  origin/android-msm-sprat-3.10-lollipop-wear-release
  origin/android-msm-sprat-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sturgeon-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sturgeon-3.10-n-preview-1-wear-release
  origin/android-msm-sturgeon-3.10-n-preview-2-wear-release
  origin/android-msm-wren-3.10-marshmallow-mr1-wear-release
  origin/master
}
检出需要编译的分支，这儿选取最新的分支：
git checkout origin/android-msm-hammerhead-3.4-marshmallow-mr2
（顺便问下，nexus 5 是不是上不去3.10内核了？）
这个时候目录下除了.git文件夹，多出来完整的代码了。

然后设置编译环境，主要就是添加交叉编译器的路径和前缀：
export ARCH=arm
export SUBARCH=arm
export CROSS_COMPILE=/home/wentao/androidKernel/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-

下一步就是定制内核配置了。
按理来说，编译device对应的内核，最好从当前使用的内核中拷贝出配置文件，然后进行修改，这个最为保险，一般而言当前使用的内核配置可以用adb来拷贝出来：
adb pull /proc/config.gz
如果没有这个配置文件，就使用当前内核代码中的工具，生成一个默认配置（貌似是亲儿子系列独有？）：
make hammerhead_defconfig

回显：
{
  HOSTCC  scripts/basic/fixdep
  HOSTCC  scripts/kconfig/conf.o
  SHIPPED scripts/kconfig/zconf.tab.c
  SHIPPED scripts/kconfig/zconf.lex.c
  SHIPPED scripts/kconfig/zconf.hash.c
  HOSTCC  scripts/kconfig/zconf.tab.o
  HOSTLD  scripts/kconfig/conf
#
# configuration written to .config
#
}
生成了.config文件，然后生成编译需要的配置文件：
make menuconfig
如果有需要修改的就保存后退出。然后开始编译：
make -j4
当出现：
{
OBJCOPY arch/arm/boot/zImage
Kernel: arch/arm/boot/zImage is ready
CAT     arch/arm/boot/zImage-dtb
Kernel: arch/arm/boot/zImage-dtb is ready
}
表示编译内核成功结束。

接下来就需要根据编译成功的结果制作可以写入的内核镜像了。
首先从原来的boot.img入手，将这个旧的镜像用unmkbootimg分解：
mkdir image
cd image
unmkbootimg -i boot.img
回显：
{
kernel written to 'kernel' (8331496 bytes)
ramdisk written to 'ramdisk.cpio.gz' (498796 bytes)
	To rebuild this boot image, you can use the command:
    mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead  user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1' --kernel kernel --ramdisk ramdisk.cpio.gz -o boot_img/boot.img
}
然后原来的boot.img解压出：kernel和ramdisk.cpio.gz 两个文件。
然后用我们自己编译的进行替换：
cp ../msm/arch/arm/boot/zImage-dtb kernel_new
然后开始用这个新的内核进行打包：
mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead  user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1' --kernel kernel_new --ramdisk ramdisk.cpio.gz -o boot_new.img
这样新的可以直接刷入的boot_new.img就成功制作好了。

最后刷入新的内核进行开机测试：
adb start-server
adb reboot bootloader
fastboot flash boot boot_new.img
fastboot reboot
测试一下自己编译的内核有没有正常运行吧。



<2>HMN3pro内核编译：
从xda上的HM3PRO板块找到android 6的可用的内核（也就是CM13），找到：
http://forum.xda-developers.com/redmi-note-3/development/kernel-infected-kernel-r1-t3422554
然后从 https://github.com/neonkat/kenzo_kernel 下载源代码：
git clone https://github.com/neonkat/kenzo_kernel.git
下载代码完毕之后，查看内核版本：
git branch -a
显示：
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/caf
  remotes/origin/master
  remotes/origin/test
  remotes/origin/test1
  remotes/origin/test2
表示当前版本是master，如果需要切换版本，就检出需要编译的版本，例如test2：
git checkout remotes/origin/test2
如果不需要切换版本，就准备交叉编译器。
因为是编译内核，使用通用的gcc-arm-linux-gnu也是可以的，如果不放心，可以使用android官方的工具链arm-linux-androideabi-gcc，确定好需要的交叉编译器版本之后，修改Makefile中的交叉编译器设置：
#ARCH ?= $(SUBARCH)
#CROSS_COMPILE ?=
修改成：
ARCH ?= arm
CROSS_COMPILE ?= arm-linux-gnu-
保存之后开始进行内核配置，使用这个内核自带的默认配置：
cp android/config/default.cfg ../../.config
然后使用这个配置文件来进行编译：
make defconfig





<3>构造文件系统：
参考文档：
http://blog.csdn.net/thisway_diy/article/details/51879670
http://blog.csdn.net/water_cow/article/details/6847861

（5）在docker中搭建开发环境：
基于docker官方搭建的centos7_base镜像，编写完整的开发包Dockerfile为：
{
FROM centos7_base
MAINTAINER hellmonky
LABEL name="CentOS_7 Android Build Image" \
    vendor="CentOS" \
    license="GPLv2" \
    build-date="20160728"

# 安装开发需要的包
RUN yum install -y gcc g++ kernel-devel make git wget tree

# 添加第三方epel源，安装交叉编译器：
RUN rpm -ivh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-7.noarch.rpm
RUN rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
RUN yum -y install gcc-arm-linux-gnu

CMD ["/bin/bash"]
}
编译镜像：
docker build -t android android/
然后挂载/home/wentao/docker/mountFolder文件夹作为dockerImage的工作文件夹运行：
docker run -it -v /home/wentao/docker/mountFolder:/home/mountFolder android /bin/bash


关于虚拟机NAT网卡的上网问题：
使用DHCP的方式自动获取设置，none方式失败：
TYPE="Ethernet"
BOOTPROTO="dhcp"
DEFROUTE="yes"
PEERDNS="yes"
PEERROUTES="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_PEERDNS="yes"
IPV6_PEERROUTES="yes"
IPV6_FAILURE_FATAL="no"
NAME="eno16777736"
UUID="26484f0f-fa3e-4cc1-a570-69204c000434"
DEVICE="eno16777736"
ONBOOT="yes"


