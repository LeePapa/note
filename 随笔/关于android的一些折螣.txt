关于android的一些折腾：

（0）关于android的一些基本概念：
我们从android的分区和启动顺序来进行梳理，分析下整个流程中涉及到的相关概念。

1 分区：
android系统的分区可以从线刷包中看到，一般而言线刷包是完整系统部署包，只要系统可以进入fastboot，那么就可以进行完整的系统部署。以nexus5为例，看看线刷脚本：
{
:: 开始刷入底层重要分区
:: 进行基础bootloader更新
fastboot flash bootloader bootloader-hammerhead-hhz20h.img
:: 更新完毕之后重启到这个bootloader环境下，准备后续操作
fastboot reboot-bootloader
:: 检查当前主机连通性
ping -n 5 127.0.0.1 >nul
:: 刷入基带
fastboot flash radio radio-hammerhead-m8974a-2.0.50.2.29.img
:: 重启bootloader
fastboot reboot-bootloader
ping -n 5 127.0.0.1 >nul


:: 开始刷入一般分区
:: 这个分区上有Android的引导程序，包括内核和内存操作程序。没有这个分区设备就不能被引导。恢复系统的时候会擦除这个分区，并且必须重新安装引导程序和ROM才能重启系统。
fastboot flash boot boot.img
:: 这个分区是Android系统存储频繁访问的数据和app的地方。擦除这个分区不影响你的个人数据，当你继续使用设备时，被擦除的数据就会自动被创建。
fastboot flash cache cache.img
:: recovery分区被认为是另一个启动分区，你可以启动设备进入recovery控制台去执行高级的系统恢复和管理操作。
fastboot flash recovery recovery.img
:: 这个分区上是除了内核和内存操作之外的整个操作系统。里面包含了Android用户接口和预先安装的系统应用。擦除了这个分区就会删除掉Andorid系统，所以你需要进入recovery模式或者bootloader模式去安装一个新的ROM。
fastboot flash system system.img
:: 这个分区保存着用户数据。通讯录、短信、设置和你安装的apps都在这个分区上。擦除这个分区相当于恢复出厂设置，当你第一次启动设备的时候或者在安装了官方或者客户的ROM之后系统会自动重建这个分区。当你执行恢复出厂设置时，就是在擦除这个分区。
fastboot flash userdata userdata.img
:: 到此为止，完整系统更新结束，重启进入系统
fastboot reboot
}

2 启动：
<0>Boot ROM
手机上电的时候，硬件自动从设定的地址开始执行程序，主要负责将后续的bootloader加载进入ram，然后将执行权限交给bootloader。
这部分类似于PC上的BIOS代码。

<1>Bootloader
它不属于操作系统的一部分，主要负责硬件的初始化和系统加载。
相关的代码位于：<android source>/bootable/bootloader/legacy/usbloader
主要有两个阶段：
阶段1：检查RAM，然后将阶段2的代码加载到内存中，主要涉及代码为：Init.s :: Initializes stacks, zeros the BSS segments and  call_main() in main.c
阶段2：根据预设的参数初始化网络，内存等硬件，让系统的硬件准备完毕，主要涉及代码为：Main.c :: Initializes hardware (clocks, board, keyboard, console) and creates linux tags.
因为bootloader是硬件相关的，除非是开源硬件，不然总是需要厂家进行开发和维护，而且bootloader是可以升级的，例如nexus5的官方factory线刷包中就包含了bootloader镜像，bootloader的写入是在fastboot模式下的，虽然针对分区的写入也可以在recovery中进行。
bootloader是可以被加密和上锁的：
如果加密了，那么不能对bootloader进行任何操作；
如果上锁了，用户可以通过密码解锁，然后进行操作。
所以一般手机厂商会上锁bootloader进行限制，然后用户通过厂商获取解锁，获取进一步的操作。
如果bootloader上锁了，是否有可能进行刷机？答案是肯定的，但是需要进行一些迂回操作：
在读取boot分区完成后，读取Android操作系统前，执行了这个所谓的recovery，所以用户看起来就像进入了recovery，这种recovery被称为2ndinit。
当从boot分区完成原厂内核的加载后，2ndboot还可以把开发者的自定义内核替换掉当前内存中的内核。
也就是说bootloader还是正常进行引导，但是在加载android系统的时候进行hack，放入自定义的recovery和kernel，重新加载完毕之后再进入android系统。虽然这样可以达到同样的效果，但是完整的解锁bootloader才能正常操作boot和recovery分区，不会造成系统不稳定。

<2>Fastboot
fastboot 主要是用来与bootloader的USB通讯的PC命令行工具。他一般主要也用来向bootloader传送刷机文件进行文件分区重烧。因此在使用时，必须有一个PC机并且USB线要始终联着。所以这种方式称为线刷。
最关键的就是用fastboot需要bootloader支持，如果bootloader只是引导内核，而不负责交互，那么fastboot是无法运行的，所以不是每一家公司产品都支的这个功能的。
如果需要使用fastboot，必须打断正常的bootloader过程，让bootloader进入支持fastboot的模式，然后用电脑端的fatboot.exe进行交互才可以操作。
这个过程是发生在bootloader的阶段二（也就是开机加电启动过程中），如果发现按键有特殊的组合，比如nexus5的双音量键和开机键，就会进入fastboot模式。这里要说的是，内核还没有加载，所以更谈不上多进程任务调度之类的概念，机器只是在顺序执行一条条的指令。
所以fastboot可以理解为实现了一个简单的通信协议，接收命令并更新镜像文件，其他什么的干不了。
fastboot模式其实是调用spl进行刷机的，所以如果刷spl坏了，fastboot模式应该也进不了，也就是砖了。SPL英文全称是Second Program Loader,“第二次装系统”，就是负责装载操作系统到RAM中。

<4>Recovery
和fastboot相同，还是在bootloader的第二阶段，如果又发现有特殊的按键组合，比如nexus 5的音量下和开机键，则会进入recovery模式。
分析recovery.img镜像文件就会发现，它里面包含了一个kernel以及一个可执行程序recovery，以及一些初始化文件。从某种意义来说，这就是一个小型操作系统，和正常启动进入的系统的kernel是一样的，只是init及之后干的事情不同。
虽然recovery中也独立的包含了内核，但是一般boot和recovery的内核是同一个，区别在于recovery里面的ramdisk会有更多recovery需要使用的程序和数据。
这里的kernel和我们常说的linux内核还是有差异的，linux内核是包括kernel以及调度器内存管理等除显示界面外完整系统。而recovery中的kernel只是指内核init进程启动前的那一段逻辑，并不是完整的linux内核。
在recovery模式下，会加载了部分文件系统，所以才可以读sdcard中的update.zip进行刷机，当然，也可以清除cache和用户数据。
因为recovery包含了一个基本的内核，并且加载了文件系统，原理上来讲，是可以作为开发环境和生成环境的。但是一般作为恢复模式进行一些文件和分区操作。

<5>ADB
ADB的全称为Android Debug Bridge，就是起到调试桥的作用。Android设备(如手机)连接PC时所需要的驱动程序，一般Android设备连接WinXP是无需安装驱动的。
通过adb我们可以通过DDMS来调试Android程序，说白了就是debug工具。
ADB是android sdk里的一个工具, 用这个工具可以直接操作管理android模拟器或者真实的andriod设备. 它的主要功能有:
	运行设备的shell(命令行)
	管理模拟器或设备的端口映射
	计算机和设备之间上传/下载文件
	将本地apk软件安装至模拟器或android设备
	ADB是一个 客户端-服务器端 程序
	客户端是你的电脑，用来操作手机
	服务器端是android设备。
要使用ADB，必须安装手机在电脑端的驱动，这样就是电脑与android 设备的通信的客户端驱动程序。



（0）红米note3高配全网通使用：
1 首先进入fastboot使用官方的线刷包进行完整的系统安装和重置；
2 然后再次进入fastboot进行官方解锁，这样就可以开启root权限，并且可以为后续的system分区读写做准备；
3 进入系统后打开adb调试功能，对system解锁：adb root; adb disable-verity; adb reboot，重启后获取到完整的root权限；
	ps:或者直接在安全中心中打算root，miui系统会自动下载root包进行重启，重启完毕之后获取root权限。
4 刷入第三方recovery：进入fastboot，然后输入：fastboot flash recovery recovery.img，成功后进入recovery进行基本操作，例如备份；
5 重新进入fastboot进行解锁，然后进入recovery刷入第三方rom，因为第三方rom会改变system的内容，所以需要重新解锁。
到这儿就完成了整个刷机过程。第三方固件需要注意底层不同会带来不同的问题，需要谨慎。
6 这个坑爹的机器，官方线刷居然不能完整恢复，如果5.1底层和6.0底层切换造成的基带丢失只能寄希望于recovery对EFS分区的备份，否则只能返厂刷机；官方固件刷一次锁一次boot，而且解锁boot需要联网小米查数据库，真心折腾。

（1）在自己安装busybox之后手动删除/system/xbin的所有内容，然后无法获取app的root之后的恢复方法：
<1>关于root的一些基本概念：
root对于android来说非常重要，因为很多定制系统的操作是需要依赖于root权限进行的。使用了root才能充分的享受android带来的自由。
参考：
http://stackoverflow.com/questions/33624228/does-deleting-system-xbin-su-prevent-root-access
内容如下：
You are mixing two type of roots.
The root you are getting from adb is calld unsecure boot, or debuggable kernel option. This is set inside the default.prop file in the ramdisk, and used in the adbd binary.
The /system/xbin/su is just a root elevation binary which in your version also has the right configuration in SE-Policy. Just deleting it will deny root for all the apps, but not for you when you debug using ADB.
If you want to disable root for yourself in adb, you can just compile as 'user' instead of userdebug or hack into the /system/core/adb binary.
<2>恢复/system/xbin/文件夹内容：
手动使用adb的shell获取su，并且重新remount rw也失败之后，重新进入recovery，然后挂载/system路径，进行文件操作，将之前的/system/xbin/su文件恢复，然后权限修改为0755，重新开机，就可以获取app的su了，然后重新安装busybox，并且建立连接，方便使用。

（2）andorid上使用linux系统：
<0>总体思路：
安卓手机启动的过程： 上电>>arm芯片调入boot的程序执行>>调用内核执行>>打开android虚拟机
所以把android手机改为嵌入式linux的方法就是：内核启动后调用自己做的文件系统，这里可以是qt等小巧的文件系统，也可以是ubuntu，debian等文件系统，也可以按自己的需求制作文件系统来进行加载。
几个关键点：
一、知道Boot怎么去调用内核，用的是什么boot程序。
二、要有内核源码，编译自己的内核，有内核源码才值得玩，内核编译好后一般只有几M大小；
三、要知道内核怎么调用文件系统，一般是一个脚本
关于内核源码，关键的还是各个模块的驱动，很多产商只提供ko文件，并不提供源码，这就不好玩了。所以手机最好选大厂商的，这些厂家公布的源码相对完善一些。
目前已经可以用的有：https://github.com/automateljw/c8812 ，这个项目提供了C8812的基本引导。
参考文档：https://www.embbnux.com/2014/03/31/android_to_embeded_linux_board/
<1>共生安装方式：
如果不想破坏原来的安卓系统，用下面两个方法体验和使用Linux桌面比较好：
1. 直接安装Linux到SD卡上。这种情况是运行一个完整的Linux版本。可以使用别人构建好的镜像，一句dd if=xxxx.img of=/dev/sdX命令，就可以安装Linux系统到sd卡。然后根据制造商的不同，关机使用不同的按键组合就能从SD引导运行这个Linux系统。但是这种镜像要有针对你的手机或平板的驱动，你才能用一些功能，比如说最基本的lcd屏要能显示、触摸屏至少要能用吧。

2. 在安卓系统之上，利用安卓本身的Linux内核、服务和应用程序来运行Linux桌面。基本的原理都是chroot。但在使用图形界面这一块，有些不同：
2.1 用的最多的是VNC，在Linux系统里运行一个VNC服务器，然后用安卓下的VNC客户端连接就可以了。但是这种方法在配置一般的手机或平板上运行不流畅。
2.2 也可以使用Xserver应用（还没有Wayland或Mir），这比起VNC的速度比较慢的协议来说，效率要高一些，但是目前的Xserver基本不实用：http://blog.sina.com.cn/s/blog_59cf67260101bvjf.html。
2.3. 关掉安卓服务，直接运行原生的Xorg，在这基础之上运行Linux桌面。
运行原生的Xorg有以下好处：
a. 比VNC：流畅。我的全志A10单核1.0GHz的机器，基本上有我原来那个赛扬的老机器用Windows XP的流畅度了。
b. 比TF卡：方便。不用重启机器，按各种按钮，就能切换到各种Linux桌面。
c. 比TF卡：方便。同上，玩完Linux，不用重启机器，就可以重新回到安卓。当然，这一点比VNC要差一点，这是由于没有人开发比较完整的Xserver。（或者Wayland、Mir也行啊）。
d. 比TF卡：还是方便。能直接用安卓下的驱动，不用从源码编译驱动。
e. 就和虚拟机一样，可以无痛的体验任何linux系统，只要有它的rootfs就行了。
<2>介绍linuxdeploy：
linuxdeploy是俄国老毛子大神meefik开发的，官方网站是：https://github.com/meefik/linuxdeploy，上面安装busybox也是用的他的：https://github.com/meefik/busybox
linuxdeploy总体上的思路就是和<1>中所述基本相同，实现的本质上是chroot 和 mount，所以安装的linux系统需要和自己的手机的CPU架构相符合，并且有足够的空间来进行放置img镜像。
这样就可以简单的通过文件来进行恢复和操作系统的切换了，只要android系统还在运行，就可以mount和unmount不同的操作系统来玩了。
参考文档：http://forum.ubuntu.org.cn/viewtopic.php?f=177&t=450030
<3>安装linuxdeploy：
参考教程：
http://blog.csdn.net/leekwen/article/details/45093093
http://www.oneplusbbs.com/thread-628385-1-1.html
https://www.kali.org/tutorials/kali-linux-android-linux-deploy/
http://forum.ubuntu.org.cn/viewtopic.php?t=463818
http://www.freebuf.com/articles/terminal/13209.html
http://tieba.baidu.com/p/3310711970
http://tieba.baidu.com/p/4212305788
另一种方式：
http://forum.ubuntu.org.cn/viewtopic.php?t=451917
<4>原理描述：
基本就是创建一个img的映像文件，然后联网获取对应系统的rootfs些到这个镜像中，然后chroot这个img就可以启动这个linux系统了。
这样所依赖的内核还是基本的android内核，
<5>备份和还原：
备份和还原一直都是linux系统的关键。linuxdeploy支持导出rootfs的tar包，并且可以通过对img和配置文件的备份来起到完整备份作用。

（3）在linuxdeploy中使用ubuntu：
<1>安装中文字体：
进入ssh：
输入用户名和密码changme
安装中文字体：
cd /home/wentao
wget http://jaist.dl.sourceforge.net/project/wqy/wqy-microhei/0.2.0-beta/wqy-microhei-0.2.0-beta.tar.gz
tar -xvf wqy-microhei-0.2.0-beta.tar.gz -C /home/wentao
sudo mv wqy-microhei /usr/share/fonts/
sudo chmod 555 /usr/share/fonts/wqy-microhei/*
cd /usr/share/fonts/wqy-microhei/
sudo mkfontscale
sudo mkfontdir
sudo fc-cache -fv
这样进入vnc之后就可以看到中文了。
<2>安装基本的docker支持：
sudo apt-get install docker.io
因为性能问题，只能保证可以用，不建议使用。
<3>安装jdk环境：
因为是arm64位架构，所以使用的jdk也需要适配这个版本：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
选择Linux ARM 64 Hard Float ABI
将下载的包拷贝到手机内置的sdcard中，然后进入ssh进行解压缩和安装：
tar -xvf /mnt/0/jdk.tar.gz -C /usr/local/bin
然后设置环境变量：
nano /etc/profile
添加以下内容：
export JAVA_HOME=/usr/local/bin/jdk1.8.0_101
export CLASSPATH=.:$CLASSPTAH:$JAVA_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin
生效：
source /etc/profile
检查：
java -version
返回：
java version "1.8.0_101"
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
表示当前已经安装成功了。
随着Oracle官方的Oracle Java 7 JDK (硬件浮点)支持被加入，现在ARM平台可以直接用官方的JDK了。
参考：http://blog.csdn.net/mirkerson/article/details/8082065/
<4>安装javaIDE：


参考文档：http://blog.csdn.net/mirkerson/article/details/8082065/

（4）android学习：
<0>开发环境：
使用centos7_X64版本来进行开发，并且使用docker来隔离开发环境。
首先安装系统基本的开发环境：
yum groupinstall "Development Tools"
或者选择安装最小开发环境：
yum install -y gcc g++ kernel-devel make git
参考文档：http://www.diogogmt.com/2015/09/19/installing-build-essentials-on-centos-7-and-ubuntu-14-03/

<1>设置系统代理：
开发android，那么代理必不可少。使用ss可以比较稳定的解决问题。并且CentOS 7 开始默认使用Systemd作为开启启动脚本的管理工具。所以整个安装如下：
首先安装ss：
#安装 python setup tools
yum install python-setuptools
#安装pip
easy_install pip
#升级 pip
pip install --upgrade pip
#安装 shadowsocks
pip install shadowsocks
然后创建 shadowsocks 服务, 随系统启动：
nano /usr/lib/systemd/system/shadowsocks.service
写入如下内容：
{
[Unit]
Description=Shadowsocks Server
Documentation=https://github.com/shadowsocks/shadowsocks
After=network.target remote-fs.target nss-lookup.target

[Service]
Type=forking
#设置启动时的配置文件,根据自己的需求改。这儿使用：/usr/shadowsocks.json作为要读入的配置文件
ExecStart=/usr/bin/sslocal -c /usr/shadowsocks.json -d start
ExecReload=/bin/kill -HUP $MAINPID
ExecStop=/usr/bin/sslocal -d stop

[Install]
WantedBy=multi-user.target
}
PS：注意这儿是sslocal，而不是ssserver，表示服务器。
添加配置文件:
#改为上一步中的路径, 确保各级目录存在
nano /usr/shadowsocks.json
写入配置内容（包含大括号，是一个json串）:
{
  "server": "0.0.0.0",
  "server_port": "8388",
  "password": "uzon57jd0v869t7w",
  "method": "aes-256-cfb"
}
保存后退出，然后启动服务：
systemctl enable shadowsocks
systemctl start shadowsocks
为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态：
systemctl status shadowsocks -l
如果回显：
{
● shadowsocks.service - Shadowsocks Server
   Loaded: loaded (/usr/lib/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)
   Active: inactive (dead) since 二 2016-08-16 04:36:37 CST; 31s ago
     Docs: https://github.com/shadowsocks/shadowsocks
  Process: 13444 ExecStop=/usr/bin/ssserver -d stop (code=exited, status=0/SUCCESS)
  Process: 13430 ExecStart=/usr/bin/ssserver -c /usr/shadowsocks.json -d start (code=exited, status=0/SUCCESS)

8月 16 04:36:37 localhost.localdomain systemd[1]: Starting Shadowsocks Server...
8月 16 04:36:37 localhost.localdomain ssserver[13430]: INFO: loading config from /usr/shadowsocks.json
8月 16 04:36:37 localhost.localdomain ssserver[13430]: 2016-08-16 04:36:37 INFO     loading libcrypto from libcrypto.so.10
8月 16 04:36:37 localhost.localdomain ssserver[13444]: 2016-08-16 04:36:37 ERROR    not running
8月 16 04:36:37 localhost.localdomain systemd[1]: Started Shadowsocks Server.
}
表示已经启动成功了。
如果失败，有可能是防火墙的缘故，8989是默认端口，需要按照自己购买的ss端口进行设置：
首先安装防火墙：
yum install firewalld
然后设置：
firewall-cmd --permanent --add-port=8989/tcp
firewall-cmd --reload
由于 Shadowsocks 使用的是 SOCKS5 协议，必须把 SOCKS5 请求转化为 HTTP 协议请求，墙内服务器的其他软件才能使用该代理。

安装privoxy做转换：
yum -y install privoxy
编辑Privoxy配置文件，将SOCKS5协议转化为HTTP协议：
nano /etc/privoxy/config
添加以下内容（这最后面确实有个英文句号，不要遗漏）：
{
forward-socks5 / 127.0.0.1:1080 .
}
设置Privoxy随系统自动启动：
systemctl enable privoxy
启动Privoxy：
systemctl start privoxy
查看Privoxy状态：
systemctl status privoxy
如果有 running 和 active 字样，说明成功运行。

安装polipo做转换：polipo是一个轻量级的缓存web代理程序。
yum install polipo
打开配置文件
nano /etc/polipo/config
设置ParentProxy为Shadowsocks，通常情况下本机shadowsocks的地址如下：
{
# Uncomment this if you want to use a parent SOCKS proxy:
socksParentProxy = "localhost:1080"
socksProxyType = socks5
}
设置日志输出文件：
{
logFile=/var/log/polipo
logLevel=4
}

如果上述两个程序都无法安装，建议使用第三方源：
yum install epel-release
参考：http://www.cnblogs.com/edward2013/p/5021308.html
这样就可以直接安装上面两个软件了。

如果还不放心，可以下载软件的源代码包自己编译安装。privoxy官方网站：http://www.privoxy.org/sf-download-mirror/Sources/
找到最新的稳定版，然后编译后安装。
wget http://www.privoxy.org/sf-download-mirror/Sources/3.0.24%20%28stable%29/privoxy-3.0.24-stable-src.tar.gz
编译需要的工具安装：
yum install w3m lynx links
然后解压缩：
tar xf privoxy-3.0.24-stable-src.tar.gz
autoheader && autoconf
./configure
make && make install
然后根据安装位置修改配置文件完成配置。

如果需要整个系统访问外网，可以使用VPN来做整个系统的代理：
安装软件包
yum install pptp pptp-setup
初始化一个VPN的连接通道：myvpn
pptpsetup --create ss --server xxx.xxx.xxx.xxx --username xxx --password xxx --encrypt --start
这个命令会在/etc/ppp/peers目录下面，会生成一个叫ss的文件，并且在/etc/ppp目录下面，用户名和密码会写在chap-secrets文件中：
回显：
{
Using interface ppp0
Connect: ppp0 <--> /dev/pts/1
CHAP authentication succeeded
MPPE 128-bit stateless compression enabled
local  IP address 192.168.0.136
remote IP address 192.168.0.1
}
开启/关闭VPN：添加 pon、poff 到/usr/sbin下
cp /usr/share/doc/ppp-2.4.5/scripts/pon /usr/sbin
cp /usr/share/doc/ppp-2.4.5/scripts/poff /usr/sbin
chmod +x /usr/sbin/pon /usr/sbin/poff
这样就可以通过pon/poff <tunnel> 来启停VPN连接
开启VPN
pon ss
关闭VPN
pon ss
删除vpn连接通道：myvpn
pptpsetup --delete ss




<1>android内核与GUN/linux内核的区别：
android虽然基于linux，但是他不同于kernel.org所维护的linux内核上建立的完整的linux系统，并且在内核上还进行了定制，主要在于驱动上，并且根据手机端的特性对电源管理等进行了修改。也正因为驱动的原因，android被从linux树种移除了。
既然android还是基于linux的内核，并且有所不同，那么就一定要仔细分析差异，然后对比学习。
细节参考：http://www.cnblogs.com/manuosex/p/3590207.html
概述参考：
http://blog.csdn.net/juana1/article/details/6648518
http://tech.it168.com/a2011/0725/1222/000001222793.shtml
<2>应用开发之间的差异：
那么是不是除去驱动在两者之间分别为：编译好的.ko文件和开放源代码之间的差异，就没有什么不同？并不是，除了驱动的不同，两者在linux内核基础上使用的C库也不一样。
传统的linux系统中的程序基本都依赖于GNU C Library (glibc)，google自己打造了一个C的运行时库，称为Bionic Library (bionic)。
因为google的官方Toolchain也是基于Bionic Libc而并非glibc的。这使得使用或移植其他Toolchain来用于Android要比较麻烦：在Google公布用于Android的官方Toolchain之前，多数的Android爱好者使用的Toolchain是在http://www.codesourcery.com/gnu_toolchains/arm/download.html 下载的一个通用的Toolchain，它用来编译和移植Android 的Linux内核是可行的，因为内核并不需要C库，但是开发Android的应用程序时，直接采用或者移植其他的Toolchain都比较麻烦，其他Toolchain编译的应用程序只能采用静态编译的方式才能运行于Android模拟器中，这显然是实际开发中所不能接受的方式。目前尚没有看到说明成功移植其他交叉编译器来编译Android应用程序的资料。
与glibc相比，Bionic Libc有如下一些特点：
- 采用BSD License，而不是glibc的GPL License；
- 大小只有大约200k，比glibc差不多小一半，且比glibc更快；
- 实现了一个更小、更快的pthread；
- 提供了一些Android所需要的重要函数，如”getprop”, “LOGI”等；
- 不完全支持POSIX标准，比如C++ exceptions，wide chars等；
- 不提供libthread_db 和 libm的实现
另外，Android中所用的其他一些二进制工具也比较特殊：
- 加载动态库时使用的是/system/bin/linker而不是常用的/lib/ld.so;
- prelink工具不是常用的prelink而是apriori，其源代码位于” <your_android>/build/tools/apriori”
- strip工具也没有采用常用的strip，即“<your_android>/prebuilt/linux-x86/toolchain/arm-eabi-4.2.1/bin”目录下的arm-eabi-strip，而是位于<your_android>/out/host/linux-x86/bin/的soslim工具。
Bionic的官方git地址为：
https://android.googlesource.com/platform/bionic/
github镜像地址为：
https://github.com/android/platform_bionic

细节参考：
http://blog.csdn.net/andyhuabing/article/details/7183369
http://blog.csdn.net/gzzaigcnforever/article/details/7480101


（）android内核编译：
作为整个android的底层，内核提供了对整体硬件的控制和性能的限制，很多开源硬件运行用户自定义内核来达到某些特殊需求，作为基本的geek，编译和定制内核是必须的。现在进入android内核的编译环节，这部分最大的不同在于交叉编译器的使用。
1 初始环境设置和工具链安装：
因为android也是属于linux内核的一种，只需要编译内核而不需要依赖别的组件，所以对toolchain(NDK)的选择上宽松得多。大体来讲有这样几种可能性：自己编译arm-eabi的gcc toolchain，使用Sourcery的toolchain，使用Google提供的NDK构建toolchain，或者使用第三方（比如crystax）修改过的NDK。
<0>系统初始环境设置：
首先系统必须安装有基本的编译环境：
yum -y install gcc make git
<1>通用交叉编译环境：
需要安装交叉编译环境才能在PC端进行嵌入式的开发，所以需要这个基本环境。然而centos官方源中并不支持这个程序，所以需要安装第三方源：
安装EPEL源：
rpm -ivh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-7.noarch.rpm
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
检查是否安装成功：
yum repolist
查看某个包的详细信息：
yum --enablerepo=epel info htop
列出epel源的所有包列表：
yum --disablerepo="*" --enablerepo="epel" list available | less
然后安装交叉编译器：
yum -y install gcc-arm-linux-gnu
检查是否安装成功：
arm-linux-gnu-gcc --version
回显：
arm-linux-gnu-gcc (GCC) 4.8.1 20130717 (Red Hat 4.8.1-5)
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
表示已经安装成功。并且这样安装的交叉编译器已经添加到环境变量中，不再需要用户设置。
参考文档：
http://www.ha97.com/5649.html
https://pkgs.org/centos-7/epel-x86_64/gcc-arm-linux-gnu-4.8.1-5.2.el7.1.x86_64.rpm.html
<2>从googleNDK获取开发工具：
编译android相关的内容，最好使用google提供的工具链，包括编译内核，可以减少不必要的麻烦。官方下载地址为：https://developer.android.com/ndk/downloads/index.html
例如下载：android-ndk-r12b-linux-x86_64.zip
下载之后根据当前的系统，在压缩包的toolchains目录下选择对应的包，解压到某一个目录中，然后将这个目录添加到系统环境变量中。
$export PATH=$PATH:/myandroid/androidsrc/prebuilt/linux-x86/toolchain/arm-eabi-4.2.1/bin
<3>从google官方工具库获取：
从官方维护网站：https://android.googlesource.com/platform/prebuilts/gcc/
下载对应版本的工具链，然后安装：
git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9
安装方法同上。
<4>第三方修改的工具链：
和上面类似，需要手动安装并且添加到环境变量中去。关键就是选取的第三方工具链的来源。
PS:最后选取<3>方法的4.7版本交叉编译器。

2 内核代码编译：
作为linux系统的核心，内核就是根本，之前的linuxDeploy也是利用了已经提供支持的内核才得以跑起来。
针对android手机的内核编译，因为驱动的原因，尽量选择出货量大的，大型公司的产品，支持和开源会做的好一点。
<1>nexus 5内核编译：
作为官方亲儿子，编译内核方面还是有足够的支持的，并且初学编译内核，使用亲儿子可以减少干扰，降低编译难度。
参考文档：http://www.roboby.com/android%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3.html
操作系统为ubuntu14.04_X64
sudo apt-get install gcc make git libncurses5-dev
下载boot.img打包程序：
git clone https://github.com/pbatard/bootimg-tools.git
cd bootimg-tools/
make
cd cpio/
gcc mkbootfs.c  -o mkbootfs -I../include
cd ../..
mkdir andorid_boot_tools_bin
cd andorid_boot_tools_bin/
cp ../bootimg-tools/mkbootimg/mkbootimg .
cp ../bootimg-tools/mkbootimg/unmkbootimg .
cp ../bootimg-tools/cpio/mkbootfs .
cd ..
这样就在bootimg-tools文件夹中生成了构建boot镜像的可执行文件。
（这儿编译cpio/mkbootfs.c文件的时候报错，但是整个流程中并没有使用到mkbootfs来构建boot时文件系统，而是直接使用了已有打包boot.img中解压出来的文件系统）

准备编译环境设置脚本：
nano run_this_android.sh
内容如下：
{
# 设置交叉编译器位置
export CC=$(pwd)/arm-eabi-4.7/bin/arm-eabi-
export CROSS_COMPILE=$(pwd)/arm-eabi-4.7/bin/arm-eabi-
# 设置编译内核架构
export ARCH=arm
export SUBARCH=arm
# 设置boot.img生成工具
export PATH=$PATH:$(pwd)/android_boot_tools
}
然后设置为可执行，然后再当前终端中生效：
chmod +x run_this_android.sh
source run_this_android.sh

交叉编译器的选择：
目前使用的是来自 https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-eabi-4.7/ 的交叉编译器，而不是上面小节中的 https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9 因为就算是修改了权限，还是有问题，这个留给以后解决。

设置交叉编译器的权限（这一步非常关键）：
因为是从windows下代理下载官方的构建工具，所以权限是有问题的，所以一定要对交叉编译器目录进行整体的权限设置：
chmod -R +x arm-eabi-4.7/
然后对其中的bin目录设置为755权限：
chmod -R 755 bin/*
（之前没有这样设置，会有各种编译的权限问题，并且造成无法写入的错误）

完成基本环境设置之后，在官方内核代码页面找到代码同步目录：
http://source.android.com/source/building-kernels.html#figuring-out-which-kernel-to-build
选择：
Device		Binary location					Source location		Build configuration
hammerhead	device/lge/hammerhead-kernel	kernel/msm			hammerhead_defconfig
确定git路径：
git clone https://android.googlesource.com/kernel/msm
挂载代理下载完整的代码。
然后查看当前代码树的分支：
git branch -r
显示结果为：
{
origin/HEAD -> origin/master
  origin/android-msm-2.6.35
  origin/android-msm-3.9-usb-and-mmc-hacks
  origin/android-msm-angler-3.10-marshmallow-dr
  origin/android-msm-angler-3.10-marshmallow-dr1.5
  origin/android-msm-angler-3.10-marshmallow-dr1.6
  origin/android-msm-angler-3.10-marshmallow-dr1.6-1
  origin/android-msm-angler-3.10-marshmallow-mr1
  origin/android-msm-angler-3.10-n-preview-1
  origin/android-msm-angler-3.10-n-preview-2
  origin/android-msm-angler-3.10-n-preview-3
  origin/android-msm-angler-3.10-n-preview-4
  origin/android-msm-angler-3.10-n-preview-5
  origin/android-msm-anthias-3.10-lollipop-mr1-wear-release
  origin/android-msm-anthias-3.10-lollipop-wear-release
  origin/android-msm-anthias-3.10-marshmallow-mr1-wear-release
  origin/android-msm-asus-3.10-lollipop-mr1-wear-release
  origin/android-msm-asus-3.10-marshmallow-mr1-wear-release
  origin/android-msm-bass-3.10-lollipop-mr1-wear-release
  origin/android-msm-bass-3.10-marshmallow-mr1-wear-release
  origin/android-msm-bullhead-3.10-marshmallow-dr
  origin/android-msm-bullhead-3.10-marshmallow-dr-0
  origin/android-msm-bullhead-3.10-marshmallow-dr1.5
  origin/android-msm-bullhead-3.10-marshmallow-dr1.6
  origin/android-msm-bullhead-3.10-marshmallow-mr1
  origin/android-msm-bullhead-3.10-marshmallow-mr1-eas
  origin/android-msm-bullhead-3.10-marshmallow-mr2
  origin/android-msm-bullhead-3.10-n-preview-1
  origin/android-msm-bullhead-3.10-n-preview-2
  origin/android-msm-bullhead-3.10-n-preview-3
  origin/android-msm-bullhead-3.10-n-preview-4
  origin/android-msm-bullhead-3.10-n-preview-5
  origin/android-msm-dory-3.10-kitkat-wear
  origin/android-msm-dory-3.10-lollipop-mr1-wear-release
  origin/android-msm-dory-3.10-lollipop-wear-release
  origin/android-msm-dory-3.10-marshmallow-mr1-wear-release
  origin/android-msm-flo-3.4-jb-mr2
  origin/android-msm-flo-3.4-kitkat-mr0
  origin/android-msm-flo-3.4-kitkat-mr1
  origin/android-msm-flo-3.4-kitkat-mr2
  origin/android-msm-flo-3.4-l-preview
  origin/android-msm-flo-3.4-lollipop-mr1
  origin/android-msm-flo-3.4-lollipop-mr1.1
  origin/android-msm-flo-3.4-lollipop-mr1.2
  origin/android-msm-flo-3.4-lollipop-release
  origin/android-msm-flo-3.4-marshmallow
  origin/android-msm-flo-3.4-marshmallow-mr1
  origin/android-msm-flo-3.4-marshmallow-mr2
  origin/android-msm-hammerhead-3.4-kitkat-mr1
  origin/android-msm-hammerhead-3.4-kitkat-mr2
  origin/android-msm-hammerhead-3.4-kk-fr1
  origin/android-msm-hammerhead-3.4-kk-fr2
  origin/android-msm-hammerhead-3.4-kk-r1
  origin/android-msm-hammerhead-3.4-l-preview
  origin/android-msm-hammerhead-3.4-lollipop-mr1
  origin/android-msm-hammerhead-3.4-lollipop-mr1.1
  origin/android-msm-hammerhead-3.4-lollipop-release
  origin/android-msm-hammerhead-3.4-m-preview
  origin/android-msm-hammerhead-3.4-marshmallow
  origin/android-msm-hammerhead-3.4-marshmallow-mr1
  origin/android-msm-hammerhead-3.4-marshmallow-mr2
  origin/android-msm-huawei-3.10-lollipop-mr1-wear-release
  origin/android-msm-huawei-3.10-lollipop-mr1-wear-release-1
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release-1
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release-2
  origin/android-msm-lego-3.10-marshmallow-dr
  origin/android-msm-lenok-3.10-kitkat-wear
  origin/android-msm-lenok-3.10-lollipop-mr1-wear-release
  origin/android-msm-lenok-3.10-lollipop-wear-release
  origin/android-msm-lenok-3.10-marshmallow-mr1-wear-release
  origin/android-msm-mako-3.4-jb-mr1
  origin/android-msm-mako-3.4-jb-mr1-fr
  origin/android-msm-mako-3.4-jb-mr1-kgsl
  origin/android-msm-mako-3.4-jb-mr1.1
  origin/android-msm-mako-3.4-jb-mr2
  origin/android-msm-mako-3.4-kitkat-mr0
  origin/android-msm-mako-3.4-kitkat-mr1
  origin/android-msm-mako-3.4-kitkat-mr2
  origin/android-msm-mako-3.4-lollipop-mr1
  origin/android-msm-mako-3.4-lollipop-mr1.1
  origin/android-msm-mako-3.4-lollipop-release
  origin/android-msm-moto-3.10-lollipop-mr1-wear-release
  origin/android-msm-nemo-3.10-marshmallow-mr1-wear-release
  origin/android-msm-nemo-3.10-n-preview-1-wear-release
  origin/android-msm-nemo-3.10-n-preview-2-wear-release
  origin/android-msm-seed-3.10-lollipop-mr1
  origin/android-msm-seed-3.10-marshmallow
  origin/android-msm-seed-3.10-marshmallow-mr1
  origin/android-msm-seed-3.10-marshmallow-mr2
  origin/android-msm-seed-3.10-n-preview-2
  origin/android-msm-seed-3.10-n-preview-3
  origin/android-msm-seed-3.10-n-preview-4
  origin/android-msm-seed-3.10-n-preview-5
  origin/android-msm-shamu-3.10-lollipop-mr1
  origin/android-msm-shamu-3.10-lollipop-release
  origin/android-msm-shamu-3.10-m-preview
  origin/android-msm-shamu-3.10-marshmallow
  origin/android-msm-shamu-3.10-marshmallow-mr1
  origin/android-msm-shamu-3.10-marshmallow-mr1-r0.15
  origin/android-msm-shamu-3.10-marshmallow-mr2
  origin/android-msm-shamu-3.10-n-preview-1
  origin/android-msm-shamu-3.10-n-preview-2
  origin/android-msm-shamu-3.10-n-preview-3
  origin/android-msm-shamu-3.10-n-preview-4
  origin/android-msm-shamu-3.10-n-preview-5
  origin/android-msm-smelt-3.10-lollipop-mr1-wear-release
  origin/android-msm-smelt-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sony-cm-jb-3.0
  origin/android-msm-sparrow-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sprat-3.10-kitkat-wear
  origin/android-msm-sprat-3.10-lollipop-mr1-wear-release
  origin/android-msm-sprat-3.10-lollipop-wear-release
  origin/android-msm-sprat-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sturgeon-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sturgeon-3.10-n-preview-1-wear-release
  origin/android-msm-sturgeon-3.10-n-preview-2-wear-release
  origin/android-msm-wren-3.10-marshmallow-mr1-wear-release
  origin/master
}
检出需要编译的分支，这儿选取最新的分支：
git checkout origin/android-msm-hammerhead-3.4-marshmallow-mr2
（顺便问下，nexus 5 是不是上不去3.10内核了？）
这个时候目录下除了.git文件夹，多出来完整的代码了。

然后设置编译环境，主要就是添加交叉编译器的路径和前缀：
export ARCH=arm
export SUBARCH=arm
export CROSS_COMPILE=/home/wentao/androidKernel/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-

下一步就是定制内核配置了。
按理来说，编译device对应的内核，最好从当前使用的内核中拷贝出配置文件，然后进行修改，这个最为保险，一般而言当前使用的内核配置可以用adb来拷贝出来：
adb pull /proc/config.gz
如果没有这个配置文件，就使用当前内核代码中的工具，生成一个默认配置（貌似是亲儿子系列独有？）：
make hammerhead_defconfig

回显：
{
  HOSTCC  scripts/basic/fixdep
  HOSTCC  scripts/kconfig/conf.o
  SHIPPED scripts/kconfig/zconf.tab.c
  SHIPPED scripts/kconfig/zconf.lex.c
  SHIPPED scripts/kconfig/zconf.hash.c
  HOSTCC  scripts/kconfig/zconf.tab.o
  HOSTLD  scripts/kconfig/conf
#
# configuration written to .config
#
}
生成了.config文件，然后生成编译需要的配置文件：
make menuconfig
如果有需要修改的就保存后退出。然后开始编译：
make -j4
当出现：
{
OBJCOPY arch/arm/boot/zImage
Kernel: arch/arm/boot/zImage is ready
CAT     arch/arm/boot/zImage-dtb
Kernel: arch/arm/boot/zImage-dtb is ready
}
表示编译内核成功结束。

接下来就需要根据编译成功的结果制作可以写入的内核镜像了。
首先从原来的boot.img入手，将这个旧的镜像用unmkbootimg分解：
mkdir image
cd image
unmkbootimg -i boot.img
回显：
{
kernel written to 'kernel' (8331496 bytes)
ramdisk written to 'ramdisk.cpio.gz' (498796 bytes)
	To rebuild this boot image, you can use the command:
    mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead  user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1' --kernel kernel --ramdisk ramdisk.cpio.gz -o boot_img/boot.img
}
然后原来的boot.img解压出：kernel和ramdisk.cpio.gz 两个文件。
然后用我们自己编译的进行替换：
cp ../msm/arch/arm/boot/zImage-dtb kernel_new
然后开始用这个新的内核进行打包：
mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead  user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1' --kernel kernel_new --ramdisk ramdisk.cpio.gz -o boot_new.img
这样新的可以直接刷入的boot_new.img就成功制作好了。
通过上述分析，可以知道android所使用的内核格式是Linux标准的zImage，根文件系统采用ramdisk格式。这两者在Android下是直接合并在一起取名为boot.img,会放在一个独立分区当中。一般而言，这个分区会独立存在，称为boot分区。

最后刷入新的内核进行开机测试：
adb start-server
adb reboot bootloader
fastboot flash boot boot_new.img
fastboot reboot
测试一下自己编译的内核有没有正常运行吧。


<2>HMN3pro内核编译：
从xda上的HM3PRO板块找到android 6的可用的内核（也就是CM13），找到：
http://forum.xda-developers.com/redmi-note-3/development/kernel-infected-kernel-r1-t3422554
然后从 https://github.com/neonkat/kenzo_kernel 下载源代码：
git clone https://github.com/neonkat/kenzo_kernel.git
下载代码完毕之后，查看内核版本：
git branch -a
显示：
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/caf
  remotes/origin/master
  remotes/origin/test
  remotes/origin/test1
  remotes/origin/test2
表示当前版本是master，如果需要切换版本，就检出需要编译的版本，例如test2：
git checkout remotes/origin/test2
如果不需要切换版本，就准备交叉编译器。
因为是编译内核，使用通用的gcc-arm-linux-gnu也是可以的，如果不放心，可以使用android官方的工具链arm-linux-androideabi-gcc，确定好需要的交叉编译器版本之后，修改Makefile中的交叉编译器设置：
#ARCH ?= $(SUBARCH)
#CROSS_COMPILE ?=
修改成：
ARCH ?= arm
CROSS_COMPILE ?= arm-linux-gnu-
保存之后开始进行内核配置，使用这个内核自带的默认配置：
cp android/config/default.cfg ../../.config
然后使用这个配置文件来进行编译：
make defconfig


<3>关于第三方内核包的解析：
如果设备开源了，或者泄露了内核代码，那么内核高手就可以根据这些已经开放出来的内核代码进行修改和定制，形成各种各样的第三方内核包。一般而言，最后给用户的是一个zip包，用来支持卡刷升级。现在以hmn3pro为例，选取第三方内核包Radon-V2.1-Kenzo.zip为例进行说明。
整个zip包的结构为：
Radon-V2.1-Kenzo.zip
│
├─META-INF
│  │  CERT.RSA
│  │  CERT.SF
│  │  MANIFEST.MF
│  │
│  └─com
│      └─google
│          └─android
│                  update-binary
│                  updater-script
│                  updater-script~
│
├─system
│  └─lib
│      └─modules
│              wlan.ko
│
└─tools
        dt.img
        flash_kernel.sh
        Image
        mkbootimg
        unpackbootimg
要分析这个包的具体结构，需要明确的一点就是这个zip包是供recovery来刷入的，所以一定符合recovery的要求（官方和第三方都是一个标准）。
下面就针对目录和文件说明功能：
(a)META-INF目录，这个目录存放关于这个刷机包的元信息，主要包含以下内容：
 CERT.RSA:(签名文件相关,保存公匙和加密算法)
 CERT.SF:(签名文件相关,保存私匙,CERT代表签名者)
 MAINFEST.MF:(这个manifest文件定义了与包的组成结构相关的数据)
 com/google/android/update-binary:(一个脚本解释器，能够识别updater-script中描述的操作)
 com/google/android/updater-script:(脚本文件，具体描述了更新过程)
 com/google/android/metadata:(描述设备信息及环境变量的元数据)
其中最关键的就是com/google/android/updater-script这个脚本，定义了刷机中的操作。
(b)system目录，这个目录的内容在升级后会放在系统的system分区。主要用来更新系统的一些应用或则应用会用到的一些库等等。
可以从上面的内容看出，这个库主要包含了一个内核驱动文件。也就是说更新这个内核的时候，同时更新了一个wifi的内核驱动模块。
(c)tools目录是一个自建目录，也就是说这个目录不会被自动释放，他的设置和com/google/android/updater-script密切相关。
接下来根据updater-script的内容来分析下整个内核zip包的行为，首先这个脚本的格式为edify，edify有两个主要的文件。这些文件可以在.zip文件内的META-INF/com/google/android文件夹中找到。它们是：
update-binary -- 当用户选择刷入.zip（通常是在恢复模式中）时所执行的二进制解释器。
updater-script -- 安装脚本，它是一个文本文件。
所以整个事件有了眉目，这个zip包包含了特殊的目录结构，并且可以被recovery解压缩识别，然后完成功能的主要核心部件是edify的两个文件，包含一个解释器和一个脚本，这个脚本控制了整个zip包的执行内容，并且顺序执行。
关于脚本，它包含了基本的函数来调用实现功能和展示，简单介绍为：
{
1、mount
语法：
mount(type, location, mount_point);
说明：
type="MTD" location="<partition>" 挂载yaffs2文件系统分区；
type="vfat" location="/dev/block/<whatever>" 挂载设备。
例如：
mount("MTD", "system", "/system");挂载system分区，设置返回指针"/system”
mount("vfat", "/dev/block/mmcblk1p2", "/system");
挂载/dev/block/mmcblk1p2，返回指针"/system”
2、Unmount
语法：
unmount(mount_point);
说明：
mount_point是mount所设置产生的指针。其作用与挂载相对应，卸载分区或设备。此函数与mount配套使用。
例如：
unmount("/system");
卸载/system分区
3、Format
语法：
format(type, location);
说明：
type="MTD" location=partition（分区），格式化location参数所代表的分区。
例如：
format("MTD", "system");格式化system分区
4、Delete
语法：
delete(<path>);
说明：
删除文件<path>
例如：
delete("/data/zipalign.log");删除文件/data/zipalign.log
5、delete_recursive
语法：
delete_recursive(<path>);
说明：
删除文件夹<path>
例如：
delete_recursive("/data/dalvik-cache");删除文件夹/data/dalvik-cache
6、show_progress
语法：
show_progress(<fraction>,<duration>);
说明：
为下面进行的程序操作显示进度条，进度条会根据<duration>进行前进<fraction>
例如：
show_progress(0.1, 10);show_progress下面的操作可能进行10s，完成后进度条前进0.1（也就是10%）
7、package_extract_dir
语法：
package_extract_dir(package_path, destination_path);
说明：
释放文件夹package_path至destination_path
例如：
package_extract_dir("system", "/system");释放ROM包里system文件夹下所有文件和子文件夹至/system
8、package_extract_file
语法：
package_extract_file(package_path, destination_path);
说明：
解压package_path文件至destination_path
例如：
package_extract_dir("my.zip", "/system");解压ROM包里的my.zip文件至/system
9、Symlink
语法：
symlink(<target>, <src1>, <src2>,...);
说明：
建立指向target符号链接src1，src2，……
例如：
symlink("toolbox", "/system/bin/ps");建立指向toolbox的符号链接/system/bin/ps
10、set_perm
语法：
set_perm(<uid>, <gid>,<mode>, <path>);
说明：
设置<path>文件的用户为uid，用户组为gid，权限为mode
例如：
set_perm(1002, 1002, 0440, "/system/etc/dbus.conf");设置文件/system/etc/dbus.conf的所有者为1002，所属用户组为1002，权限为：所有者有读权限，所属用户组有读权限，其他无任何权限。
11、set_perm_recursive
语法：
set_perm_recursive(<uid>,<gid>,<dir-mode>,<file-mode>,<path>);
说明：
设置文件夹和文件夹内文件的权限
例如：
set_perm_recursive(1000, 1000, 0771, 0644, "/data/app");设置/data/app的所有者和所属用户组为1000，app文件夹的权限是：所有者和所属组拥有全部权限，其他有执行权限；app文件夹下的文件权限是：所有者有读写权限，所属组有读权限，其他有读权限。
12、ui_print
语法：
ui_print("str");
说明：
屏幕打印输出"str"
例如：
ui_print("It's ready!");屏幕打印It’s ready!
13、run_program
语法：
run_program(<path>);
说明：
运行<path>脚本
例如：
run_program("/sbin/busybox","mount","/system")；
14、write_raw_image
语法：
write_raw_image(<path>, partition);
说明：
写入<path>至partition分区
例如：
write_raw_image("/tmp/boot.img", "boot")将yaffs2格式的boot包直接写入boot分区
15、assert
语法：
assert(<sub1>,<sub2>,<sub3>);
说明：
如果执行sub1不返回错误则执行sub2，如果sub2不返回错误则执行sub3一次类推。
例如：
assert(package_extract_file("boot.img", "/tmp/boot.img"),
write_raw_image("/tmp/boot.img", "boot"),
delete("/tmp/boot.img"));执行package_extract_file，如果不返回错误则执行write_raw_image，如果write_raw_image不出错则执行delete[1]
}
根据这个基本内容，分析当前的脚本含义（除去用户端输出）：
{
ui_print(" ");
ui_print("===================================");
# 解压缩tools文件夹到内存文件系统的/tmp目录下
package_extract_dir("tools", "/tmp");
ui_print(" ");
ui_print("Extracting Files");
# 设置/tmp/mkbootimg文件的用户为0，用户组为0，权限为0777；也就是说用户为root，组为root，权限0777表示有读和写以及执行的权限
set_perm(0, 0, 0777, "/tmp/mkbootimg");
set_perm(0, 0, 0777, "/tmp/unpackbootimg");
set_perm(0, 0, 0777, "/tmp/flash_kernel.sh");
# 运行/tmp/flash_kernel.sh脚本
run_program("/tmp/flash_kernel.sh");
ui_print(" ");
ui_print("Flashing Radon Kernel");
# 删除内存文件系统中的文件
delete("/tmp/boot.img");
delete("/tmp/mkbootimg");
delete("/tmp/unpackbootimg");
delete("/tmp/flash_kernel.sh");
# 挂载位于/dev/block/bootdevice/by-name/system的ext4文件系统EMMC分区，返回到/system路径下
mount("ext4", "EMMC", "/dev/block/bootdevice/by-name/system", "/system");
ui_print(" ");
ui_print("Installing kernel modules");
ui_print(" ");
# 将当前的system路径解压到/system路径下，会完整的释放整个文件目录的路径中
package_extract_dir("system", "/system");
# 解除/system路径下的文件系统挂载
unmount("/system");
ui_print("Done, Enjoy Radon Power !");
ui_print(" ");
ui_print("===================================");
ui_print(" ");
}
这样就展示了完整的刷机过程，其中调用了一个最为关键的脚本，就是位于/tools/flash_kernel.sh，现在继续看看这个脚本的内容：
{
cd /tmp/
/sbin/busybox dd if=/dev/block/bootdevice/by-name/boot of=./boot.img
./unpackbootimg -i /tmp/boot.img
./mkbootimg --kernel /tmp/Image --ramdisk /tmp/boot.img-ramdisk.gz --cmdline "console=ttyHSL0,115200,n8 androidboot.console=ttyHSL0 androidboot.hardware=qcom msm_rtb.filter=0x237 ehci-hcd.park=3 androidboot.bootdevice=7824900.sdhci lpm_levels.sleep_disabled=1 earlyprintk"  --base 0x80000000 --pagesize 2048 --ramdisk_offset 0x02000000 --tags_offset 0x01e00000 --dt /tmp/dt.img -o /tmp/newboot.img
/sbin/busybox dd if=/tmp/newboot.img of=/dev/block/bootdevice/by-name/boot
}
总共5条命令，现在分析如下：
第一条：进入到当前文件系统的/tmp目录下；
第二条：执行/sbin/busybox下的dd命令，指定输入文件为：/dev/block/bootdevice/by-name/boot，输出文件为：当前路径下的boot.img。也就是说保存当前系统的boot分区到当前文件夹下的boot.img文件中；
第三条：使用当前路径下的unpackbootimg命令，用-i参数解开/tmp/boot.img文件。也就是将原始boot分区的内容解压，会解压出以下内容：
	boot.img-zImage (内核文件）
	boot.img-ramdisk.gz (根文件系统打包文件）
	boot.img-cmdline (mkbootimg cmdline参数)
	boot.img-pagesize (mkbootimg pagesize参数)
	boot.img-base (mkbootimg base参数)
最主要的就是zImage和ramdisk文件了。
第四条：使用当前路径下的mkbootimg命令来打包新的内核，并且指定了新的内核文件为/tmp/Image，而根文件系统还是从原来boot.img中解压出来的boot.img-ramdisk.gz文件，最后输出为/tmp/newboot.img。这里有一个点，是android4之后出现的，那就是"--dt /tmp/dt.img"这个参数，
第五条：


<3>构造文件系统：
参考文档：
http://blog.csdn.net/thisway_diy/article/details/51879670
http://blog.csdn.net/water_cow/article/details/6847861

（5）在docker中搭建开发环境：
基于docker官方搭建的centos7_base镜像，编写完整的开发包Dockerfile为：
{
FROM centos7_base
MAINTAINER hellmonky
LABEL name="CentOS_7 Android Build Image" \
    vendor="CentOS" \
    license="GPLv2" \
    build-date="20160728"

# 安装开发需要的包
RUN yum install -y gcc g++ kernel-devel make git wget tree

# 添加第三方epel源，安装交叉编译器：
RUN rpm -ivh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-7.noarch.rpm
RUN rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
RUN yum -y install gcc-arm-linux-gnu

CMD ["/bin/bash"]
}
编译镜像：
docker build -t android android/
然后挂载/home/wentao/docker/mountFolder文件夹作为dockerImage的工作文件夹运行：
docker run -it -v /home/wentao/docker/mountFolder:/home/mountFolder android /bin/bash


关于虚拟机NAT网卡的上网问题：
使用DHCP的方式自动获取设置，none方式失败：
TYPE="Ethernet"
BOOTPROTO="dhcp"
DEFROUTE="yes"
PEERDNS="yes"
PEERROUTES="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_PEERDNS="yes"
IPV6_PEERROUTES="yes"
IPV6_FAILURE_FATAL="no"
NAME="eno16777736"
UUID="26484f0f-fa3e-4cc1-a570-69204c000434"
DEVICE="eno16777736"
ONBOOT="yes"


（）在centos7下编译android源代码(AOSP源代码)：
<0>基础环境设置：
# fetch source
sudo yum install git
sudo yum install wget
# to compile
sudo yum install java-1.7.0-openjdk
sudo yum install java-1.7.0-openjdk-devel
sudo yum install glibc.i686
sudo yum install libstdc++.i686
sudo yum install bison
sudo yum install zip
sudo yum install unzip
综合一条命令搞定：
yum -y install git wget java-1.7.0-openjdk java-1.7.0-openjdk-devel glibc.i686 libstdc++.i686 bison zip unzip
而且由于源代码编译需要的资源过多，建议使用8G内存的pc，否则会导致jvm内存不足错误。建议使用实体机或者服务器虚拟机进行编译。
<1>下载repo工具：
国内因为被墙的原因，无法直接访问google服务器，所以需要照国内的代理源来下载android的源代码。
android开源使用repo来完成源代码的管理，这个repo文件是一个python脚本，并且使用git来下载源代码，所以系统中必须安装git和python。现在在root目录下建立source文件夹包含所有内容，包含bin目录和androidSource目录。
mkdir /root/source/bin
PATH=/root/source/bin:$PATH
curl https://storage.googleapis.com/git-repo-downloads/repo > /root/source/bin/repo
chmod a+x /root/source/binrepo
或者使用相同的数字权限：
chmod 777 /root/source/binrepo
<2>修改repo中的下载源为清华大学下载源:
编辑/root/source/bin/repo，将REPO_URL 一行替换成下面的：
{
REPO_URL = 'https://gerrit-google.tuna.tsinghua.edu.cn/git-repo'
}
<3>选择特定的Android版本，如果是Nexus系列，你可以从关于手机中的版本号（build number）中从列表中找到对应的版本。也可以访问官方网站找到对应的版本：
https://source.android.com/source/build-numbers.html#source-code-tags-and-builds
这儿选取nexus 5的源代码包，分支为：android-6.0.1_r60，所以下载代码为：
mkdir androidSource
cd androidSource
repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r60
<4>同步下载源码树：
repo sync -j4
其中，-j4表示并发数为4，清华镜像只支持最大并发数4。
下载完源代码大约需要35G的空间，清华大学的源速度还不错，自测下载速度可以达到3M/s,大约3小时下载完。如果为了节约空间的话，那么可以删除下载好的源代码目录下的.repo文件夹，但是这样就失去了同步的能力。
<5>下载官方提供的驱动包：
根据官方网站：https://developers.google.com/android/nexus/drivers 给出的android设备对应android版本来下载对应的AOSP驱动包。这儿选择：Nexus 5 (GSM/LTE) binaries for Android 6.0.1 (MOB30Y)，然后添加进入源代码中：
进入android源代码目录，下载驱动代码包：
cd source
# Broadcom for NFC, Bluetooth, Wi-Fi
wget https://dl.google.com/dl/android/aosp/broadcom-hammerhead-mob30y-d12b1bea.tgz
# LG for Camera, Sensors, Audio
wget https://dl.google.com/dl/android/aosp/lge-hammerhead-mob30y-546d280a.tgz
# Qualcomm for Graphics, GSM, Camera, GPS, Sensors, Media, DSP, USB
wget https://dl.google.com/dl/android/aosp/qcom-hammerhead-mob30y-d90ee87e.tgz
然后解压进入驱动目录：
ls *.tgz |xargs -n1 tar -zxvf
for i in extract*; do sed -n '/tail/p' $i | sed "s/\$0/$i/" | sh; done
PS：增加驱动代码包非常重要，如果不加入这个，可以用来进行模拟器启动，但是刷入实体机的时候因为驱动的缺失导致无法开机。
这三个压缩包都只包含了一个.sh脚本，但是在这个脚本中则是二进制的驱动，使用这个脚本来动态生成驱动。这个也就是linux主线为什么要去除android内核的缘故吧。封闭和开放。
<6>准备编译环境：
用envsetup.sh（它在源代码根目录/build下面）脚本初始化环境，注意后面的lunch命令等都跟这一步有没有执行有关。如果没有执行后面会提示找不到lunch命令。
source build/envsetup.sh
<7>选择编译目标：
用lunch命令选择编译目标.额外的配置可以用参数传递。例如：
lunch aosp_arm-eng
其中参数aosp_arm-eng，指的是一个适用于模拟器的完整编译版本,带编译的版本。如果直接使用lunch命令不带参数，系统会弹出选项卡，让你选择对应的版本。所有的编译目标的格式都是:BUILD-BUILDTYPE，BUILD指的是指定特性的结合。其中BUILDTYPE是下面列出的其中一个：
	Buildtype		用途
	user			有限的权限；适合一般用户
	userdebug		类似user模式，但有root权限和debug能力，适合debug
	eng				带有额外的debug工具的开发配置。
这儿因为选取的是nexus 5，所以代号为hammerhead，对应的编译选项为：
lunch aosp_hammerhead-userdebug
或者输入lunch，然后选择19，出现的结果为：
{
============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=6.0.1
TARGET_PRODUCT=aosp_hammerhead
TARGET_BUILD_VARIANT=userdebug
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
TARGET_ARCH_VARIANT=armv7-a-neon
TARGET_CPU_VARIANT=krait
TARGET_2ND_ARCH=
TARGET_2ND_ARCH_VARIANT=
TARGET_2ND_CPU_VARIANT=
HOST_ARCH=x86_64
HOST_OS=linux
HOST_OS_EXTRA=Linux-3.10.0-327.28.2.el7.x86_64-x86_64-with-centos-7.2.1511-Core
HOST_BUILD_TYPE=release
BUILD_ID=MOB30Y
OUT_DIR=out
=============================================
}
<8>开始编译：
make -j4 >> compiler.log
很简单，就直接make好了，然后将日志写入到文件中，方便查看记录和排查错误。
等待编译完成后，会产生如下重要文件：
{
android-info.txt
boot.img
cache.img
ramdisk.img
recovery.img
system.img
userdata.img
}
这些文件跟后面烧录的过程有关，非常重要。一般他们在源代码路径下的out文件夹中。具体来说就是在：源代码根目录/out/debug/target/product/hammerhead/目录下。
也可以用源代码根目录下输入 find . -name system.img查找具体的路径在哪里。
<9>刷机测试：
编译完毕之后，<8>中列出的img文件就是我们需要的最终结果了，现在需要将这些生成的镜像烧录到手机上实测是否可以正确运行。
由于本人是在服务器上进行编译的，然后再本机进行刷机测试，故采用打包的方式进行刷机。将上述文件打包为zip格式，然后编辑脚本：flash-all.bat
{
@ECHO OFF
:: 其中-w 选项清空设备上的/data分区，在第一次烧录的时候很有必要，但其他时候就不是必须的。
fastboot -w update images.zip
fastboot reboot
echo Press any key to exit...
pause >nul
exit
}
将手机切换到fastboot模式，使用这个脚本更新系统：
flash-all.bat
稍等片刻，刷入完毕之后就自动重启进入系统。
如果一切顺利，你已经用上了自己根据官方开源编译出来的完整android系统。恭喜！
<10>源代码的备份：
由于android系统源代码非常大，并且每次下载都非常缓慢，建议一下下载之后打包存储，将本机下载的源代码包上传到服务器备份：
scp -r /home/wentao/android/source root@192.168.1.100:/home/local_disk/
将会把本地的source文件夹上传到服务器的local_disk路径下。
可以通过命令：
du -h --max-depth=1 文件夹
查看当前文件夹的大小，来进行上传监控。
或者使用tar+ssh的方式，可以直接备份到异地，减少在本地生成备份包，及通过内部网络传输来降低tar+gzip打包时对磁盘的IO压力。
(a)tar本地调用gzip打包压缩，然后用ssh传输到远程服务器，在远程服务器通过dd of的方式创建文件：
tar zcvf - /home/wentao/android/source | ssh root@192.168.1.100 "dd of=/home/local_disk/source2.tar.gz"
在远程服务器通过cat >的方式创建文件：
tar zcvf - /home/wentao/android/source | ssh root@192.168.1.100 "cat > /home/local_disk/source.tar.gz"
对比测试，发现使用dd命令要快一点。
(b)也可以本地服务器进行打包，再到异地服务器进行压缩:
tar cvf - /home/wentao/android/source | ssh root@192.168.1.100 "gzip -1 > /home/local_disk/source.tar.gz"
(c)需要从远程服务器中直接解压压缩包到本地为：
ssh root@192.168.1.100 "cat /home/local_disk/nexus5.tar.gz" | tar zxvf -
(d)本地打包压缩传输到异地解压:
tar -czf - /home/wentao/android/source | ssh root@192.168.0.100 "cd /mail;tar -zxf -"


（）编译TWRP：
作为刷机必须使用的恢复系统分区，recovery有着非常重要的作用。目前针对触摸屏最著名的开源的recovery项目为TWRP，官方网站为：https://twrp.me/，并且提供了开源的github地址：https://github.com/TeamWin/Team-Win-Recovery-Project
官方给出了编译教程：http://forum.xda-developers.com/showthread.php?p=32965365#post32965365
对于编译recovery，比较特殊的是它是和整个android源代码包结合在一起的，需要使用类似于AOSP项目一样的完整代码，然后进行编译。目前hammerhead的TWRP维护者建议使用omni来编译整个recovery。
<0>系统准备：
首先设置代理：话说下载AOSP代码使用清华的repo都是可以的，就是这个omni不行！
export http_proxy="127.0.0.1:1080"
export https__proxy="127.0.0.1:1080"
然后和之前的AOSP项目相同的基础环境准备；然后使用google的官方repo，并且添加到系统环境变量中：
PATH=/home/wentao/android/bin:$PATH
<1>下载omni的源代码：
选取最新的android-6.0分支：
repo init -u git://github.com/omnirom/android.git -b android-6.0
然后同步下载代码：
repo sync
<2>编译：
因为omni自带twrp的recovery，所以只需要lunch对应的版本，然后针对recovery编译就行。

废弃：
{
<1>设备对应的源代码获取：
因为目前维护人员的减少，很多设备的twrp被放在其他项目中维护，从hammerhead的官方下载网页：https://twrp.me/devices/lgnexus5.html ，得到目前最新的版本维护人员为：Dees_Troy，并且得到维护的代码树地址：
https://github.com/omnirom/android_device_lge_hammerhead
那么我们的源代码获取就从这儿来。
下载最新的源代码，记得选取分支为android 6.0版本：
git clone https://github.com/omnirom/android_device_lge_hammerhead.git
单独下载的代码量很小，只有15M左右。
<2>修改配置文件：BoardConfig.mk
这个文件一般放在：devices/manufacturer/codename，对应于hammerhead就是：devices/lge/hammerhead/BoardConfig.mk。上述下下载的git源代码，则直接放置在根路径下。一般我们自定义的修正放在这个文件的最后，并且进行标注。
<3>扩展RECOVERY.FSTAB：
在twrp2.5及以上版本支持recovery.fstab来增强TWRP's backup/restore能力。但是需要注意的是，目前twrp所支持的fstab格式版本。
<4>加入修改过的源代码包到AOSP源代码中：
然后使用之前的开发环境进行编译：
source build/envsetup.sh
lunch 19
然后选择只编译recovery：
make -j4 recoveryimage
make recoveryimage -j8
找到生成的镜像，然后刷机：

（）适配TWRP还未官方支持的设备：
https://github.com/Gaojiquan/android_bootable_recovery/wiki/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91Recovery
http://tieba.baidu.com/p/3196418541
http://www.romjd.com/jiaocheng/content/9336
}

注意：关于android底层的编译和测试阶段结束，现在的关键在于总体上对整个流程进行把握，而不是陷入recovery等细节中，所以这部分内容暂时搁置，现在主要学习两个方面：
	<1>linux内核基础知识，关键在于驱动方面，并且和android针对linux内核中驱动部分的修改；
	<2>android framework的整体架构，充分理解底层定制的c库，jvm定制版的性能，已经程序开发。
根据上述内容，下面的主要内容集中在：
	<1>linux的内核驱动：
	<2>android整体架构：
	<3>android定制jvm特性，art相关的虚拟环境：
	<4>android程序开发流程：
	<5>android并行程序开发：

	
（）搭建framework源代码开发IDE环境：
为了实现上面的目标，需要我们搭建完整的AOSP开发环境，上述章节中我们已经可以完整的编译整个代码了，但是查找和修改代码还是很不方便。如果有IDE支持就会方便很多。
我们使用Android Studio来完成对AOSP源代码的查看和修改：
<0>安装Android Studio：
unzip解压缩到/usr/local/bin目录下，然后进入解压目录的bin目录下，执行：
./studio.sh
就可以启动了。需要注意的是比较耗资源，最好在实体机上进行操作。
然后会自动下载androidSDK来支持开发，如果已经下载了，可以在studio启动的时候手动设置位置来免去下载。
ps：当然也可以通过编译AOSP代码来生成SDK，然后在android studio中导入这个自己编译生成的SDK来进行应用开发。
编译SDK的命令为：
make sdk
生成的结果放在：
../out/host/linux-x86/sdk/目录下面，是一个zip文件包。
<1>完整编译一次AOSP，这样做的目的是为了生成idegen工具需要使用到的jar包 – idegen.jar。
如果你make成功之后，发现在../out/host/linux-x86/framework目录下没有生成这个文件，那么可以自己手动编译：
cd ../development/tools/idegen/
mm
mmma development/tools/idegen/
这之后就会生成idegen.jar。
<2>执行idegen.sh：
../development/tools/idegen/idegen.sh
耐心等待，过一会就会在根目录下生成两个文件，android.iml和android.ipr，这就是我们需要的。
<3>使用Intellij/Android Studio打开工程文件：
打开Intellij和Android Studio，File->open->android.ipr，或者Andoird Stuido， Open an existing Android Studio project -> android.ipr所在目录, 之后就是漫长的等待，需要花很久的时间建立索引。

总体上：先进行AOSP代码的命令行编译，执行成功之后再安装android studio是一个不错的选择。可以说整个AOSP包含了所有相关的代码，生成的文件也能满足android开发的所有需求，再结合IDEA这个编辑器可以非常好的进行开发工作。剩下的事情就是结合linux内核知识RTFSC了。
