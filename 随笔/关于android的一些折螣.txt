关于android的一些折腾：

（0）关于android的一些基本概念：
我们从android的分区和启动顺序来进行梳理，分析下整个流程中涉及到的相关概念。

1 分区：
android系统的分区可以从线刷包中看到，一般而言线刷包是完整系统部署包，只要系统可以进入fastboot，那么就可以进行完整的系统部署。以nexus5为例，看看线刷脚本：
{
:: 开始刷入底层重要分区
:: 进行基础bootloader更新
fastboot flash bootloader bootloader-hammerhead-hhz20h.img
:: 更新完毕之后重启到这个bootloader环境下，准备后续操作
fastboot reboot-bootloader
:: 检查当前主机连通性
ping -n 5 127.0.0.1 >nul
:: 刷入基带
fastboot flash radio radio-hammerhead-m8974a-2.0.50.2.29.img
:: 重启bootloader
fastboot reboot-bootloader
ping -n 5 127.0.0.1 >nul


:: 开始刷入一般分区
:: 这个分区上有Android的引导程序，包括内核和内存操作程序。没有这个分区设备就不能被引导。恢复系统的时候会擦除这个分区，并且必须重新安装引导程序和ROM才能重启系统。
fastboot flash boot boot.img
:: 这个分区是Android系统存储频繁访问的数据和app的地方。擦除这个分区不影响你的个人数据，当你继续使用设备时，被擦除的数据就会自动被创建。
fastboot flash cache cache.img
:: recovery分区被认为是另一个启动分区，你可以启动设备进入recovery控制台去执行高级的系统恢复和管理操作。
fastboot flash recovery recovery.img
:: 这个分区上是除了内核和内存操作之外的整个操作系统。里面包含了Android用户接口和预先安装的系统应用。擦除了这个分区就会删除掉Andorid系统，所以你需要进入recovery模式或者bootloader模式去安装一个新的ROM。
fastboot flash system system.img
:: 这个分区保存着用户数据。通讯录、短信、设置和你安装的apps都在这个分区上。擦除这个分区相当于恢复出厂设置，当你第一次启动设备的时候或者在安装了官方或者客户的ROM之后系统会自动重建这个分区。当你执行恢复出厂设置时，就是在擦除这个分区。
fastboot flash userdata userdata.img
:: 到此为止，完整系统更新结束，重启进入系统
fastboot reboot
}

2 启动：
<0>Boot ROM
手机上电的时候，硬件自动从设定的地址开始执行程序，主要负责将后续的bootloader加载进入ram，然后将执行权限交给bootloader。
这部分类似于PC上的BIOS代码。

<1>Bootloader
它不属于操作系统的一部分，主要负责硬件的初始化和系统加载。
相关的代码位于：<android source>/bootable/bootloader/legacy/usbloader
主要有两个阶段：
阶段1：检查RAM，然后将阶段2的代码加载到内存中，主要涉及代码为：Init.s :: Initializes stacks, zeros the BSS segments and  call_main() in main.c
阶段2：根据预设的参数初始化网络，内存等硬件，让系统的硬件准备完毕，主要涉及代码为：Main.c :: Initializes hardware (clocks, board, keyboard, console) and creates linux tags.
因为bootloader是硬件相关的，除非是开源硬件，不然总是需要厂家进行开发和维护，而且bootloader是可以升级的，例如nexus5的官方factory线刷包中就包含了bootloader镜像，bootloader的写入是在fastboot模式下的，虽然针对分区的写入也可以在recovery中进行。
bootloader是可以被加密和上锁的：
如果加密了，那么不能对bootloader进行任何操作；
如果上锁了，用户可以通过密码解锁，然后进行操作。
所以一般手机厂商会上锁bootloader进行限制，然后用户通过厂商获取解锁，获取进一步的操作。
如果bootloader上锁了，是否有可能进行刷机？答案是肯定的，但是需要进行一些迂回操作：
在读取boot分区完成后，读取Android操作系统前，执行了这个所谓的recovery，所以用户看起来就像进入了recovery，这种recovery被称为2ndinit。
当从boot分区完成原厂内核的加载后，2ndboot还可以把开发者的自定义内核替换掉当前内存中的内核。
也就是说bootloader还是正常进行引导，但是在加载android系统的时候进行hack，放入自定义的recovery和kernel，重新加载完毕之后再进入android系统。虽然这样可以达到同样的效果，但是完整的解锁bootloader才能正常操作boot和recovery分区，不会造成系统不稳定。

<2>Fastboot
fastboot 主要是用来与bootloader的USB通讯的PC命令行工具。他一般主要也用来向bootloader传送刷机文件进行文件分区重烧。因此在使用时，必须有一个PC机并且USB线要始终联着。所以这种方式称为线刷。
最关键的就是用fastboot需要bootloader支持，如果bootloader只是引导内核，而不负责交互，那么fastboot是无法运行的，所以不是每一家公司产品都支的这个功能的。
如果需要使用fastboot，必须打断正常的bootloader过程，让bootloader进入支持fastboot的模式，然后用电脑端的fatboot.exe进行交互才可以操作。
这个过程是发生在bootloader的阶段二（也就是开机加电启动过程中），如果发现按键有特殊的组合，比如nexus5的双音量键和开机键，就会进入fastboot模式。这里要说的是，内核还没有加载，所以更谈不上多进程任务调度之类的概念，机器只是在顺序执行一条条的指令。
所以fastboot可以理解为实现了一个简单的通信协议，接收命令并更新镜像文件，其他什么的干不了。
fastboot模式其实是调用spl进行刷机的，所以如果刷spl坏了，fastboot模式应该也进不了，也就是砖了。SPL英文全称是Second Program Loader,“第二次装系统”，就是负责装载操作系统到RAM中。

<4>Recovery
和fastboot相同，还是在bootloader的第二阶段，如果又发现有特殊的按键组合，比如nexus 5的音量下和开机键，则会进入recovery模式。
分析recovery.img镜像文件就会发现，它里面包含了一个kernel以及一个可执行程序recovery，以及一些初始化文件。从某种意义来说，这就是一个小型操作系统，和正常启动进入的系统的kernel是一样的，只是init及之后干的事情不同。
虽然recovery中也独立的包含了内核，但是一般boot和recovery的内核是同一个，区别在于recovery里面的ramdisk会有更多recovery需要使用的程序和数据。
这里的kernel和我们常说的linux内核还是有差异的，linux内核是包括kernel以及调度器内存管理等除显示界面外完整系统。而recovery中的kernel只是指内核init进程启动前的那一段逻辑，并不是完整的linux内核。
在recovery模式下，会加载了部分文件系统，所以才可以读sdcard中的update.zip进行刷机，当然，也可以清除cache和用户数据。
因为recovery包含了一个基本的内核，并且加载了文件系统，原理上来讲，是可以作为开发环境和生成环境的。但是一般作为恢复模式进行一些文件和分区操作。

<5>ADB
ADB的全称为Android Debug Bridge，就是起到调试桥的作用。Android设备(如手机)连接PC时所需要的驱动程序，一般Android设备连接WinXP是无需安装驱动的。
通过adb我们可以通过DDMS来调试Android程序，说白了就是debug工具。
ADB是android sdk里的一个工具, 用这个工具可以直接操作管理android模拟器或者真实的andriod设备. 它的主要功能有:
	运行设备的shell(命令行)
	管理模拟器或设备的端口映射
	计算机和设备之间上传/下载文件
	将本地apk软件安装至模拟器或android设备
	ADB是一个 客户端-服务器端 程序
	客户端是你的电脑，用来操作手机
	服务器端是android设备。
要使用ADB，必须安装手机在电脑端的驱动，这样就是电脑与android 设备的通信的客户端驱动程序。



（0）红米note3高配全网通使用：
1 首先进入fastboot使用官方的线刷包进行完整的系统安装和重置；
2 然后再次进入fastboot进行官方解锁，这样就可以开启root权限，并且可以为后续的system分区读写做准备；
3 进入系统后打开adb调试功能，对system解锁：adb root; adb disable-verity; adb reboot，重启后获取到完整的root权限；
	ps:或者直接在安全中心中打算root，miui系统会自动下载root包进行重启，重启完毕之后获取root权限。
4 刷入第三方recovery：进入fastboot，然后输入：fastboot flash recovery recovery.img，成功后进入recovery进行基本操作，例如备份；
5 重新进入fastboot进行解锁，然后进入recovery刷入第三方rom，因为第三方rom会改变system的内容，所以需要重新解锁。
到这儿就完成了整个刷机过程。第三方固件需要注意底层不同会带来不同的问题，需要谨慎。

（1）在自己安装busybox之后手动删除/system/xbin的所有内容，然后无法获取app的root之后的恢复方法：
<1>关于root的一些基本概念：
root对于android来说非常重要，因为很多定制系统的操作是需要依赖于root权限进行的。使用了root才能充分的享受android带来的自由。
参考：
http://stackoverflow.com/questions/33624228/does-deleting-system-xbin-su-prevent-root-access
内容如下：
You are mixing two type of roots.
The root you are getting from adb is calld unsecure boot, or debuggable kernel option. This is set inside the default.prop file in the ramdisk, and used in the adbd binary.
The /system/xbin/su is just a root elevation binary which in your version also has the right configuration in SE-Policy. Just deleting it will deny root for all the apps, but not for you when you debug using ADB.
If you want to disable root for yourself in adb, you can just compile as 'user' instead of userdebug or hack into the /system/core/adb binary.
<2>恢复/system/xbin/文件夹内容：
手动使用adb的shell获取su，并且重新remount rw也失败之后，重新进入recovery，然后挂载/system路径，进行文件操作，将之前的/system/xbin/su文件恢复，然后权限修改为0755，重新开机，就可以获取app的su了，然后重新安装busybox，并且建立连接，方便使用。

（2）andorid上使用linux系统：
<0>总体思路：
安卓手机启动的过程： 上电>>arm芯片调入boot的程序执行>>调用内核执行>>打开android虚拟机
所以把android手机改为嵌入式linux的方法就是：内核启动后调用自己做的文件系统，这里可以是qt等小巧的文件系统，也可以是ubuntu，debian等文件系统，也可以按自己的需求制作文件系统来进行加载。
几个关键点：
一、知道Boot怎么去调用内核，用的是什么boot程序。
二、要有内核源码，编译自己的内核，有内核源码才值得玩，内核编译好后一般只有几M大小；
三、要知道内核怎么调用文件系统，一般是一个脚本
关于内核源码，关键的还是各个模块的驱动，很多产商只提供ko文件，并不提供源码，这就不好玩了。所以手机最好选大厂商的，这些厂家公布的源码相对完善一些。
目前已经可以用的有：https://github.com/automateljw/c8812 ，这个项目提供了C8812的基本引导。
参考文档：https://www.embbnux.com/2014/03/31/android_to_embeded_linux_board/
<1>共生安装方式：
如果不想破坏原来的安卓系统，用下面两个方法体验和使用Linux桌面比较好：
1. 直接安装Linux到SD卡上。这种情况是运行一个完整的Linux版本。可以使用别人构建好的镜像，一句dd if=xxxx.img of=/dev/sdX命令，就可以安装Linux系统到sd卡。然后根据制造商的不同，关机使用不同的按键组合就能从SD引导运行这个Linux系统。但是这种镜像要有针对你的手机或平板的驱动，你才能用一些功能，比如说最基本的lcd屏要能显示、触摸屏至少要能用吧。

2. 在安卓系统之上，利用安卓本身的Linux内核、服务和应用程序来运行Linux桌面。基本的原理都是chroot。但在使用图形界面这一块，有些不同：
2.1 用的最多的是VNC，在Linux系统里运行一个VNC服务器，然后用安卓下的VNC客户端连接就可以了。但是这种方法在配置一般的手机或平板上运行不流畅。
2.2 也可以使用Xserver应用（还没有Wayland或Mir），这比起VNC的速度比较慢的协议来说，效率要高一些，但是目前的Xserver基本不实用：http://blog.sina.com.cn/s/blog_59cf67260101bvjf.html。
2.3. 关掉安卓服务，直接运行原生的Xorg，在这基础之上运行Linux桌面。 
运行原生的Xorg有以下好处：
a. 比VNC：流畅。我的全志A10单核1.0GHz的机器，基本上有我原来那个赛扬的老机器用Windows XP的流畅度了。
b. 比TF卡：方便。不用重启机器，按各种按钮，就能切换到各种Linux桌面。
c. 比TF卡：方便。同上，玩完Linux，不用重启机器，就可以重新回到安卓。当然，这一点比VNC要差一点，这是由于没有人开发比较完整的Xserver。（或者Wayland、Mir也行啊）。
d. 比TF卡：还是方便。能直接用安卓下的驱动，不用从源码编译驱动。
e. 就和虚拟机一样，可以无痛的体验任何linux系统，只要有它的rootfs就行了。
<2>介绍linuxdeploy：
linuxdeploy是俄国老毛子大神meefik开发的，官方网站是：https://github.com/meefik/linuxdeploy，上面安装busybox也是用的他的：https://github.com/meefik/busybox
linuxdeploy总体上的思路就是和<1>中所述基本相同，实现的本质上是chroot 和 mount，所以安装的linux系统需要和自己的手机的CPU架构相符合，并且有足够的空间来进行放置img镜像。
这样就可以简单的通过文件来进行恢复和操作系统的切换了，只要android系统还在运行，就可以mount和unmount不同的操作系统来玩了。
参考文档：http://forum.ubuntu.org.cn/viewtopic.php?f=177&t=450030
<3>安装linuxdeploy：
参考教程：
http://blog.csdn.net/leekwen/article/details/45093093
http://www.oneplusbbs.com/thread-628385-1-1.html
https://www.kali.org/tutorials/kali-linux-android-linux-deploy/
http://forum.ubuntu.org.cn/viewtopic.php?t=463818
http://www.freebuf.com/articles/terminal/13209.html
http://tieba.baidu.com/p/3310711970
http://tieba.baidu.com/p/4212305788
另一种方式：
http://forum.ubuntu.org.cn/viewtopic.php?t=451917
<4>原理描述：
基本就是创建一个img的映像文件，然后联网获取对应系统的rootfs些到这个镜像中，然后chroot这个img就可以启动这个linux系统了。
这样所依赖的内核还是基本的android内核，
<5>备份和还原：
备份和还原一直都是linux系统的关键。linuxdeploy支持导出rootfs的tar包，并且可以通过对img和配置文件的备份来起到完整备份作用。

（3）在linuxdeploy中使用ubuntu：
<1>安装中文字体：
进入ssh：
输入用户名和密码changme
安装中文字体：
cd /home/wentao
wget http://jaist.dl.sourceforge.net/project/wqy/wqy-microhei/0.2.0-beta/wqy-microhei-0.2.0-beta.tar.gz
tar -xvf wqy-microhei-0.2.0-beta.tar.gz -C /home/wentao
sudo mv wqy-microhei /usr/share/fonts/
sudo chmod 555 /usr/share/fonts/wqy-microhei/*
cd /usr/share/fonts/wqy-microhei/ 
sudo mkfontscale 
sudo mkfontdir 
sudo fc-cache -fv
这样进入vnc之后就可以看到中文了。
<2>安装基本的docker支持：
sudo apt-get install docker.io
因为性能问题，只能保证可以用，不建议使用。
<3>安装jdk环境：
因为是arm64位架构，所以使用的jdk也需要适配这个版本：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
选择Linux ARM 64 Hard Float ABI
将下载的包拷贝到手机内置的sdcard中，然后进入ssh进行解压缩和安装：
tar -xvf /mnt/0/jdk.tar.gz -C /usr/local/bin
然后设置环境变量：
nano /etc/profile
添加以下内容：
export JAVA_HOME=/usr/local/bin/jdk1.8.0_101
export CLASSPATH=.:$CLASSPTAH:$JAVA_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin
生效：
source /etc/profile
检查：
java -version
返回：
java version "1.8.0_101"
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
表示当前已经安装成功了。
随着Oracle官方的Oracle Java 7 JDK (硬件浮点)支持被加入，现在ARM平台可以直接用官方的JDK了。
参考：http://blog.csdn.net/mirkerson/article/details/8082065/
<4>安装javaIDE：


参考文档：http://blog.csdn.net/mirkerson/article/details/8082065/

（4）android学习：
<0>开发环境：
使用centos7_X64版本来进行开发，并且使用docker来隔离开发环境。
首先安装系统基本的开发环境：
yum groupinstall "Development Tools"
或者选择安装最小开发环境：
yum install -y gcc g++ kernel-devel make git
参考文档：http://www.diogogmt.com/2015/09/19/installing-build-essentials-on-centos-7-and-ubuntu-14-03/

<1>设置系统代理：
开发android，那么代理必不可少，可以使用系统代理来进行设置：


<1>android内核与GUN/linux内核的区别：
android虽然基于linux，但是他不同于kernel.org所维护的linux内核上建立的完整的linux系统，并且在内核上还进行了定制，主要在于驱动上，并且根据手机端的特性对电源管理等进行了修改。也正因为驱动的原因，android被从linux树种移除了。
既然android还是基于linux的内核，并且有所不同，那么就一定要仔细分析差异，然后对比学习。
细节参考：http://www.cnblogs.com/manuosex/p/3590207.html
概述参考：
http://blog.csdn.net/juana1/article/details/6648518
http://tech.it168.com/a2011/0725/1222/000001222793.shtml
<2>应用开发之间的差异：
那么是不是除去驱动在两者之间分别为：编译好的.ko文件和开放源代码之间的差异，就没有什么不同？并不是，除了驱动的不同，两者在linux内核基础上使用的C库也不一样。
传统的linux系统中的程序基本都依赖于GNU C Library (glibc)，google自己打造了一个C的运行时库，称为Bionic Library (bionic)。
因为google的官方Toolchain也是基于Bionic Libc而并非glibc的。这使得使用或移植其他Toolchain来用于Android要比较麻烦：在Google公布用于Android的官方Toolchain之前，多数的Android爱好者使用的Toolchain是在http://www.codesourcery.com/gnu_toolchains/arm/download.html 下载的一个通用的Toolchain，它用来编译和移植Android 的Linux内核是可行的，因为内核并不需要C库，但是开发Android的应用程序时，直接采用或者移植其他的Toolchain都比较麻烦，其他Toolchain编译的应用程序只能采用静态编译的方式才能运行于Android模拟器中，这显然是实际开发中所不能接受的方式。目前尚没有看到说明成功移植其他交叉编译器来编译Android应用程序的资料。
与glibc相比，Bionic Libc有如下一些特点：
- 采用BSD License，而不是glibc的GPL License； 
- 大小只有大约200k，比glibc差不多小一半，且比glibc更快； 
- 实现了一个更小、更快的pthread； 
- 提供了一些Android所需要的重要函数，如”getprop”, “LOGI”等； 
- 不完全支持POSIX标准，比如C++ exceptions，wide chars等； 
- 不提供libthread_db 和 libm的实现 
另外，Android中所用的其他一些二进制工具也比较特殊：
- 加载动态库时使用的是/system/bin/linker而不是常用的/lib/ld.so; 
- prelink工具不是常用的prelink而是apriori，其源代码位于” <your_android>/build/tools/apriori” 
- strip工具也没有采用常用的strip，即“<your_android>/prebuilt/linux-x86/toolchain/arm-eabi-4.2.1/bin”目录下的arm-eabi-strip，而是位于<your_android>/out/host/linux-x86/bin/的soslim工具。
Bionic的官方git地址为：
https://android.googlesource.com/platform/bionic/
github镜像地址为：
https://github.com/android/platform_bionic

细节参考：
http://blog.csdn.net/andyhuabing/article/details/7183369
http://blog.csdn.net/gzzaigcnforever/article/details/7480101


（）android内核编译：
作为整个android的底层，内核提供了对整体硬件的控制和性能的限制，很多开源硬件运行用户自定义内核来达到某些特殊需求，作为基本的geek，编译和定制内核是必须的。现在进入android内核的编译环节，这部分最大的不同在于交叉编译器的使用。
1 初始环境设置和工具链安装：
因为android也是属于linux内核的一种，只需要编译内核而不需要依赖别的组件，所以对toolchain(NDK)的选择上宽松得多。大体来讲有这样几种可能性：自己编译arm-eabi的gcc toolchain，使用Sourcery的toolchain，使用Google提供的NDK构建toolchain，或者使用第三方（比如crystax）修改过的NDK。
<0>系统初始环境设置：
首先系统必须安装有基本的编译环境：
yum -y install gcc make git
<1>通用交叉编译环境：
需要安装交叉编译环境才能在PC端进行嵌入式的开发，所以需要这个基本环境。然而centos官方源中并不支持这个程序，所以需要安装第三方源：
安装EPEL源：
rpm -ivh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-7.noarch.rpm
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
检查是否安装成功：
yum repolist
查看某个包的详细信息：
yum --enablerepo=epel info htop
列出epel源的所有包列表：
yum --disablerepo="*" --enablerepo="epel" list available | less
然后安装交叉编译器：
yum -y install gcc-arm-linux-gnu
检查是否安装成功：
arm-linux-gnu-gcc --version
回显：
arm-linux-gnu-gcc (GCC) 4.8.1 20130717 (Red Hat 4.8.1-5)
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
表示已经安装成功。并且这样安装的交叉编译器已经添加到环境变量中，不再需要用户设置。
参考文档：
http://www.ha97.com/5649.html
https://pkgs.org/centos-7/epel-x86_64/gcc-arm-linux-gnu-4.8.1-5.2.el7.1.x86_64.rpm.html
<2>从googleNDK获取开发工具：
编译android相关的内容，最好使用google提供的工具链，包括编译内核，可以减少不必要的麻烦。官方下载地址为：https://developer.android.com/ndk/downloads/index.html
例如下载：android-ndk-r12b-linux-x86_64.zip
下载之后根据当前的系统，在压缩包的toolchains目录下选择对应的包，解压到某一个目录中，然后将这个目录添加到系统环境变量中。
$export PATH=$PATH:/myandroid/androidsrc/prebuilt/linux-x86/toolchain/arm-eabi-4.2.1/bin
<3>从google官方工具库获取：
从官方维护网站：https://android.googlesource.com/platform/prebuilts/gcc/
下载对应版本的工具链，然后安装：
git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9
安装方法同上。
<4>第三方修改的工具链：
和上面类似，需要手动安装并且添加到环境变量中去。关键就是选取的第三方工具链的来源。

2 内核代码编译：
作为linux系统的核心，内核就是根本，之前的linuxDeploy也是利用了已经提供支持的内核才得以跑起来。
针对android手机的内核编译，因为驱动的原因，尽量选择出货量大的，大型公司的产品，支持和开源会做的好一点。
<1>nexus 5内核编译：
作为官方亲儿子，编译内核方面还是有足够的支持的，并且初学编译内核，使用亲儿子可以减少干扰，降低编译难度。
参考文档：http://www.roboby.com/android%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3.html
操作系统为ubuntu14.04_X64
sudo apt-get install gcc make git libncurses5-dev
下载boot.img打包程序：
git clone https://github.com/pbatard/bootimg-tools.git
cd bootimg-tools/
make
cd cpio/
gcc mkbootfs.c  -o mkbootfs -I../include
cd ../..
mkdir andorid_boot_tools_bin
cd andorid_boot_tools_bin/
cp ../bootimg-tools/mkbootimg/mkbootimg .
cp ../bootimg-tools/mkbootimg/unmkbootimg .
cp ../bootimg-tools/cpio/mkbootfs .
cd ..
这样就在bootimg-tools文件夹中生成了构建boot镜像的可执行文件。
（这儿编译cpio/mkbootfs.c文件的时候报错，但是整个流程中并没有使用到mkbootfs来构建boot时文件系统，而是直接使用了已有打包boot.img中解压出来的文件系统）

准备编译环境设置脚本：
nano run_this_android.sh
内容如下：
{
# 设置交叉编译器位置
export CC=$(pwd)/arm-eabi-4.7/bin/arm-eabi-
export CROSS_COMPILE=$(pwd)/arm-eabi-4.7/bin/arm-eabi-
# 设置编译内核架构
export ARCH=arm
export SUBARCH=arm
# 设置boot.img生成工具
export PATH=$PATH:$(pwd)/android_boot_tools
}
然后设置为可执行，然后再当前终端中生效：
chmod +x run_this_android.sh
source run_this_android.sh

交叉编译器的选择：
目前使用的是来自 https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-eabi-4.7/ 的交叉编译器，而不是上面小节中的 https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9 因为就算是修改了权限，还是有问题，这个留给以后解决。

设置交叉编译器的权限（这一步非常关键）：
因为是从windows下代理下载官方的构建工具，所以权限是有问题的，所以一定要对交叉编译器目录进行整体的权限设置：
chmod -R +x arm-eabi-4.7/
然后对其中的bin目录设置为755权限：
chmod -R 755 bin/*
（之前没有这样设置，会有各种编译的权限问题，并且造成无法写入的错误）

完成基本环境设置之后，在官方内核代码页面找到代码同步目录：
http://source.android.com/source/building-kernels.html#figuring-out-which-kernel-to-build
选择：
Device		Binary location					Source location		Build configuration
hammerhead	device/lge/hammerhead-kernel	kernel/msm			hammerhead_defconfig
确定git路径：
git clone https://android.googlesource.com/kernel/msm
挂载代理下载完整的代码。
然后查看当前代码树的分支：
git branch -r
显示结果为：
{
origin/HEAD -> origin/master
  origin/android-msm-2.6.35
  origin/android-msm-3.9-usb-and-mmc-hacks
  origin/android-msm-angler-3.10-marshmallow-dr
  origin/android-msm-angler-3.10-marshmallow-dr1.5
  origin/android-msm-angler-3.10-marshmallow-dr1.6
  origin/android-msm-angler-3.10-marshmallow-dr1.6-1
  origin/android-msm-angler-3.10-marshmallow-mr1
  origin/android-msm-angler-3.10-n-preview-1
  origin/android-msm-angler-3.10-n-preview-2
  origin/android-msm-angler-3.10-n-preview-3
  origin/android-msm-angler-3.10-n-preview-4
  origin/android-msm-angler-3.10-n-preview-5
  origin/android-msm-anthias-3.10-lollipop-mr1-wear-release
  origin/android-msm-anthias-3.10-lollipop-wear-release
  origin/android-msm-anthias-3.10-marshmallow-mr1-wear-release
  origin/android-msm-asus-3.10-lollipop-mr1-wear-release
  origin/android-msm-asus-3.10-marshmallow-mr1-wear-release
  origin/android-msm-bass-3.10-lollipop-mr1-wear-release
  origin/android-msm-bass-3.10-marshmallow-mr1-wear-release
  origin/android-msm-bullhead-3.10-marshmallow-dr
  origin/android-msm-bullhead-3.10-marshmallow-dr-0
  origin/android-msm-bullhead-3.10-marshmallow-dr1.5
  origin/android-msm-bullhead-3.10-marshmallow-dr1.6
  origin/android-msm-bullhead-3.10-marshmallow-mr1
  origin/android-msm-bullhead-3.10-marshmallow-mr1-eas
  origin/android-msm-bullhead-3.10-marshmallow-mr2
  origin/android-msm-bullhead-3.10-n-preview-1
  origin/android-msm-bullhead-3.10-n-preview-2
  origin/android-msm-bullhead-3.10-n-preview-3
  origin/android-msm-bullhead-3.10-n-preview-4
  origin/android-msm-bullhead-3.10-n-preview-5
  origin/android-msm-dory-3.10-kitkat-wear
  origin/android-msm-dory-3.10-lollipop-mr1-wear-release
  origin/android-msm-dory-3.10-lollipop-wear-release
  origin/android-msm-dory-3.10-marshmallow-mr1-wear-release
  origin/android-msm-flo-3.4-jb-mr2
  origin/android-msm-flo-3.4-kitkat-mr0
  origin/android-msm-flo-3.4-kitkat-mr1
  origin/android-msm-flo-3.4-kitkat-mr2
  origin/android-msm-flo-3.4-l-preview
  origin/android-msm-flo-3.4-lollipop-mr1
  origin/android-msm-flo-3.4-lollipop-mr1.1
  origin/android-msm-flo-3.4-lollipop-mr1.2
  origin/android-msm-flo-3.4-lollipop-release
  origin/android-msm-flo-3.4-marshmallow
  origin/android-msm-flo-3.4-marshmallow-mr1
  origin/android-msm-flo-3.4-marshmallow-mr2
  origin/android-msm-hammerhead-3.4-kitkat-mr1
  origin/android-msm-hammerhead-3.4-kitkat-mr2
  origin/android-msm-hammerhead-3.4-kk-fr1
  origin/android-msm-hammerhead-3.4-kk-fr2
  origin/android-msm-hammerhead-3.4-kk-r1
  origin/android-msm-hammerhead-3.4-l-preview
  origin/android-msm-hammerhead-3.4-lollipop-mr1
  origin/android-msm-hammerhead-3.4-lollipop-mr1.1
  origin/android-msm-hammerhead-3.4-lollipop-release
  origin/android-msm-hammerhead-3.4-m-preview
  origin/android-msm-hammerhead-3.4-marshmallow
  origin/android-msm-hammerhead-3.4-marshmallow-mr1
  origin/android-msm-hammerhead-3.4-marshmallow-mr2
  origin/android-msm-huawei-3.10-lollipop-mr1-wear-release
  origin/android-msm-huawei-3.10-lollipop-mr1-wear-release-1
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release-1
  origin/android-msm-huawei-3.10-marshmallow-mr1-wear-release-2
  origin/android-msm-lego-3.10-marshmallow-dr
  origin/android-msm-lenok-3.10-kitkat-wear
  origin/android-msm-lenok-3.10-lollipop-mr1-wear-release
  origin/android-msm-lenok-3.10-lollipop-wear-release
  origin/android-msm-lenok-3.10-marshmallow-mr1-wear-release
  origin/android-msm-mako-3.4-jb-mr1
  origin/android-msm-mako-3.4-jb-mr1-fr
  origin/android-msm-mako-3.4-jb-mr1-kgsl
  origin/android-msm-mako-3.4-jb-mr1.1
  origin/android-msm-mako-3.4-jb-mr2
  origin/android-msm-mako-3.4-kitkat-mr0
  origin/android-msm-mako-3.4-kitkat-mr1
  origin/android-msm-mako-3.4-kitkat-mr2
  origin/android-msm-mako-3.4-lollipop-mr1
  origin/android-msm-mako-3.4-lollipop-mr1.1
  origin/android-msm-mako-3.4-lollipop-release
  origin/android-msm-moto-3.10-lollipop-mr1-wear-release
  origin/android-msm-nemo-3.10-marshmallow-mr1-wear-release
  origin/android-msm-nemo-3.10-n-preview-1-wear-release
  origin/android-msm-nemo-3.10-n-preview-2-wear-release
  origin/android-msm-seed-3.10-lollipop-mr1
  origin/android-msm-seed-3.10-marshmallow
  origin/android-msm-seed-3.10-marshmallow-mr1
  origin/android-msm-seed-3.10-marshmallow-mr2
  origin/android-msm-seed-3.10-n-preview-2
  origin/android-msm-seed-3.10-n-preview-3
  origin/android-msm-seed-3.10-n-preview-4
  origin/android-msm-seed-3.10-n-preview-5
  origin/android-msm-shamu-3.10-lollipop-mr1
  origin/android-msm-shamu-3.10-lollipop-release
  origin/android-msm-shamu-3.10-m-preview
  origin/android-msm-shamu-3.10-marshmallow
  origin/android-msm-shamu-3.10-marshmallow-mr1
  origin/android-msm-shamu-3.10-marshmallow-mr1-r0.15
  origin/android-msm-shamu-3.10-marshmallow-mr2
  origin/android-msm-shamu-3.10-n-preview-1
  origin/android-msm-shamu-3.10-n-preview-2
  origin/android-msm-shamu-3.10-n-preview-3
  origin/android-msm-shamu-3.10-n-preview-4
  origin/android-msm-shamu-3.10-n-preview-5
  origin/android-msm-smelt-3.10-lollipop-mr1-wear-release
  origin/android-msm-smelt-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sony-cm-jb-3.0
  origin/android-msm-sparrow-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sprat-3.10-kitkat-wear
  origin/android-msm-sprat-3.10-lollipop-mr1-wear-release
  origin/android-msm-sprat-3.10-lollipop-wear-release
  origin/android-msm-sprat-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sturgeon-3.10-marshmallow-mr1-wear-release
  origin/android-msm-sturgeon-3.10-n-preview-1-wear-release
  origin/android-msm-sturgeon-3.10-n-preview-2-wear-release
  origin/android-msm-wren-3.10-marshmallow-mr1-wear-release
  origin/master
}
检出需要编译的分支，这儿选取最新的分支：
git checkout origin/android-msm-hammerhead-3.4-marshmallow-mr2
（顺便问下，nexus 5 是不是上不去3.10内核了？）
这个时候目录下除了.git文件夹，多出来完整的代码了。

然后设置编译环境，主要就是添加交叉编译器的路径和前缀：
export ARCH=arm
export SUBARCH=arm
export CROSS_COMPILE=/home/wentao/androidKernel/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-

下一步就是定制内核配置了。
按理来说，编译device对应的内核，最好从当前使用的内核中拷贝出配置文件，然后进行修改，这个最为保险，一般而言当前使用的内核配置可以用adb来拷贝出来：
adb pull /proc/config.gz
如果没有这个配置文件，就使用当前内核代码中的工具，生成一个默认配置（貌似是亲儿子系列独有？）：
make hammerhead_defconfig

回显：
{
  HOSTCC  scripts/basic/fixdep
  HOSTCC  scripts/kconfig/conf.o
  SHIPPED scripts/kconfig/zconf.tab.c
  SHIPPED scripts/kconfig/zconf.lex.c
  SHIPPED scripts/kconfig/zconf.hash.c
  HOSTCC  scripts/kconfig/zconf.tab.o
  HOSTLD  scripts/kconfig/conf
#
# configuration written to .config
#
}
生成了.config文件，然后生成编译需要的配置文件：
make menuconfig
如果有需要修改的就保存后退出。然后开始编译：
make -j4
当出现：
{
OBJCOPY arch/arm/boot/zImage
Kernel: arch/arm/boot/zImage is ready
CAT     arch/arm/boot/zImage-dtb
Kernel: arch/arm/boot/zImage-dtb is ready
}
表示编译内核成功结束。

接下来就需要根据编译成功的结果制作可以写入的内核镜像了。
首先从原来的boot.img入手，将这个旧的镜像用unmkbootimg分解：
mkdir image
cd image
unmkbootimg -i boot.img
回显：
{
kernel written to 'kernel' (8331496 bytes)
ramdisk written to 'ramdisk.cpio.gz' (498796 bytes)
	To rebuild this boot image, you can use the command:
    mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead  user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1' --kernel kernel --ramdisk ramdisk.cpio.gz -o boot_img/boot.img
}
然后原来的boot.img解压出：kernel和ramdisk.cpio.gz 两个文件。
然后用我们自己编译的进行替换：
cp ../msm/arch/arm/boot/zImage-dtb kernel_new
然后开始用这个新的内核进行打包：
mkbootimg --base 0 --pagesize 2048 --kernel_offset 0x00008000 --ramdisk_offset 0x02900000 --second_offset 0x00f00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead  user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1' --kernel kernel_new --ramdisk ramdisk.cpio.gz -o boot_new.img
这样新的可以直接刷入的boot_new.img就成功制作好了。

最后刷入新的内核进行开机测试：
adb start-server
adb reboot bootloader
fastboot flash boot boot_new.img
fastboot reboot
测试一下自己编译的内核有没有正常运行吧。


<2>HMN3pro内核编译：
从xda上的HM3PRO板块找到android 6的可用的内核（也就是CM13），找到：
http://forum.xda-developers.com/redmi-note-3/development/kernel-infected-kernel-r1-t3422554
然后从 https://github.com/neonkat/kenzo_kernel 下载源代码：
git clone https://github.com/neonkat/kenzo_kernel.git
下载代码完毕之后，查看内核版本：
git branch -a
显示：
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/caf
  remotes/origin/master
  remotes/origin/test
  remotes/origin/test1
  remotes/origin/test2
表示当前版本是master，如果需要切换版本，就检出需要编译的版本，例如test2：
git checkout remotes/origin/test2
如果不需要切换版本，就准备交叉编译器。
因为是编译内核，使用通用的gcc-arm-linux-gnu也是可以的，如果不放心，可以使用android官方的工具链arm-linux-androideabi-gcc，确定好需要的交叉编译器版本之后，修改Makefile中的交叉编译器设置：
#ARCH ?= $(SUBARCH)
#CROSS_COMPILE ?=
修改成：
ARCH ?= arm
CROSS_COMPILE ?= arm-linux-gnu-
保存之后开始进行内核配置，使用这个内核自带的默认配置：
cp android/config/default.cfg ../../.config
然后使用这个配置文件来进行编译：
make defconfig


<3>关于第三方内核包的解析：
如果设备开源了，或者泄露了内核代码，那么内核高手就可以根据这些已经开放出来的内核代码进行修改和定制，形成各种各样的第三方内核包。一般而言，最后给用户的是一个zip包，用来支持卡刷升级。现在以hmn3pro为例，选取第三方内核包Radon-V2.1-Kenzo.zip为例进行说明。
整个zip包的结构为：
Radon-V2.1-Kenzo.zip
│
├─META-INF
│  │  CERT.RSA
│  │  CERT.SF
│  │  MANIFEST.MF
│  │  
│  └─com
│      └─google
│          └─android
│                  update-binary
│                  updater-script
│                  updater-script~
│                  
├─system
│  └─lib
│      └─modules
│              wlan.ko
│              
└─tools
        dt.img
        flash_kernel.sh
        Image
        mkbootimg
        unpackbootimg
要分析这个包的具体结构，需要明确的一点就是这个zip包是供recovery来刷入的，所以一定符合recovery的要求（官方和第三方都是一个标准）。


<3>构造文件系统：
参考文档：
http://blog.csdn.net/thisway_diy/article/details/51879670
http://blog.csdn.net/water_cow/article/details/6847861

（5）在docker中搭建开发环境：
基于docker官方搭建的centos7_base镜像，编写完整的开发包Dockerfile为：
{
FROM centos7_base
MAINTAINER hellmonky
LABEL name="CentOS_7 Android Build Image" \
    vendor="CentOS" \
    license="GPLv2" \
    build-date="20160728"

# 安装开发需要的包
RUN yum install -y gcc g++ kernel-devel make git wget tree

# 添加第三方epel源，安装交叉编译器：
RUN rpm -ivh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-7.noarch.rpm
RUN rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
RUN yum -y install gcc-arm-linux-gnu

CMD ["/bin/bash"]
}
编译镜像：
docker build -t android android/
然后挂载/home/wentao/docker/mountFolder文件夹作为dockerImage的工作文件夹运行：
docker run -it -v /home/wentao/docker/mountFolder:/home/mountFolder android /bin/bash


关于虚拟机NAT网卡的上网问题：
使用DHCP的方式自动获取设置，none方式失败：
TYPE="Ethernet"
BOOTPROTO="dhcp"
DEFROUTE="yes"
PEERDNS="yes"
PEERROUTES="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_PEERDNS="yes"
IPV6_PEERROUTES="yes"
IPV6_FAILURE_FATAL="no"
NAME="eno16777736"
UUID="26484f0f-fa3e-4cc1-a570-69204c000434"
DEVICE="eno16777736"
ONBOOT="yes"


