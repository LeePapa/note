# 关于网络编程的学习

自动开始java编程设计之后，对网络的涉及也逐步深入。现在需要实现一个TCP/IP协议的访问接口，从java的socket编程开始起步。
本文基于网络调试环境为：windows 10 x64

## 1 学习手段
因为网络环境复杂，需要一个非常方便趁手的工具来帮助我们进行实验测试，目前选择的方式就是使用**网络抓包**或者也称为**网络嗅探**的方式来对具体协议进行分析。
本文选取的工具为Wireshark，他是一个使用[Packet Capture Library](https://en.wikipedia.org/wiki/Pcap)来进行封包捕捉，然后GUI基于Qt的跨平台sniffer软件。

libpcap（Packet Capture Library），即数据包捕获函数库，是Unix/Linux平台下的网络数据包捕获函数库。它是一个独立于系统的用户层包捕获的API接口，为底层网络监测提供了一个可移植的框架。
所以要使用wireshark需要针对不同平台提供系统相关的libpcap接口实现，常见的接口实现有：
> - 1. linux平台接口实现：[tcpdump](http://www.tcpdump.org/)
> - 2. windows平台接口实现：[Winpcap](https://www.winpcap.org/)

参考文档：
> - 1. [libpcap详解](http://blog.chinaunix.net/uid-21556133-id-120228.html)

### 1.1 WireShark基本过滤规则：
监听复杂网络会得到大量冗余信息，以至于很难找到自己需要的部分。过滤器可以帮助我们在庞杂的结果中迅速找到我们需要的信息。
同样，在使用wireshark的时候，最基本的是要熟悉这个工具提供的过滤规则，通过过滤规则的设置可以从复杂的网络嗅探结果中初步过滤我们想要的结果，然后方便后续深入分析。
wireshark提供两种过滤器：
> - 1. 捕捉过滤器：用于决定将什么样的信息记录在捕捉结果中。需要在开始捕捉前设置。
> - 2. 显示过滤器：在捕捉结果中进行详细查找。他们可以在得到捕捉结果后随意修改。

两种过滤器的目的是不同的：
> - 1. 捕捉过滤器是数据经过的第一层过滤器，它用于控制捕捉数据的数量，以避免产生过大的日志文件。
> - 2. 显示过滤器是一种更为强大（复杂）的过滤器。它允许您在日志文件中迅速准确地找到所需要的记录。

并且两种过滤器使用的语法是完全不同的。

#### 1.1.1 捕捉过滤器语法：
捕捉过滤器的语法与其它使用Lipcap（Linux）或者Winpcap（Windows）库开发的软件一样。语法为：
```shell		
[Protocol]  [Direction] [Host(s)]   [Value] [Logical Operations]    [Other expression]
```
每一项的含义为：
##### Protocol（协议）:
可能的值: ether, fddi, ip, arp, rarp, decnet, lat, sca, moprc, mopdl, tcp and udp.
如果没有特别指明是什么协议，则默认使用所有支持的协议。 

##### Direction（方向）:
可能的值: src, dst, src and dst, src or dst
如果没有特别指明来源或目的地，则默认使用 "src or dst" 作为关键字。
例如，"host 10.2.2.2"与"src or dst host 10.2.2.2"是一样的。   Host(s):
可能的值： net, port, host, portrange.
如果没有指定此值，则默认使用"host"关键字。
例如，"src 10.1.1.1"与"src host 10.1.1.1"相同。 

##### Logical Operations（逻辑运算）:
可能的值：not, and, or.
否("not")具有最高的优先级。或("or")和与("and")具有相同的优先级，运算时从左至右进行。
例如，
"not tcp port 3128 and tcp port 23"与"(not tcp port 3128) and tcp port 23"相同。
"not tcp port 3128 and tcp port 23"与"not (tcp port 3128 and tcp port 23)"不同。

举例说明：
```shell
(host 10.4.1.12 or src net 10.6.0.0/16) and tcp dst portrange 200-10000 and dst net 10.0.0.0/8
```
捕捉IP为10.4.1.12或者源IP位于网络10.6.0.0/16，目的IP的TCP端口号在200至10000之间，并且目的IP位于网络 10.0.0.0/8内的所有封包。

注意事项：
当使用关键字作为值时，需使用反斜杠“\”。
"ether proto \ip" (与关键字"ip"相同).
这样写将会以IP协议作为目标。

"ip proto \icmp" (与关键字"icmp"相同).
这样写将会以ping工具常用的icmp作为目标。 

可以在"ip"或"ether"后面使用"multicast"及"broadcast"关键字。
当您想排除广播请求时，"no broadcast"就会非常有用。 

#### 1.1.2 显示过滤器语法：
通常经过捕捉过滤器过滤后的数据还是很复杂。此时您可以使用显示过滤器进行更加细致的查找。
它的功能比捕捉过滤器更为强大，而且在您想修改过滤器条件时，并不需要重新捕捉一次。
语法为：
```shell
[Protocol]  [String 1]  [String 2]  [Comparison operator]   [Value] [Logical Operations]    [Other expression]
```

##### Protocol（协议）:
这个参数指定了可以使用的大量位于OSI模型第2至7层的协议。点击"Expression..."按钮后，您可以看到它们。
比如：IP，TCP，DNS，SSH
更为详细的协议支持可以在官方文档：[Display Filter Reference](https://www.wireshark.org/docs/dfref/)中

##### String1, String2 (可选项):
表示协议的子类。

##### Comparison operators （比较运算符）: 
可以使用6种比较运算符：
|   英文写法    |   C语言写法   |   含义  |
|--------------|-----------|-----------|
|   eq  |   ==  |   等于  |
|   ne  |   !=  |   不等于  |
|   gt  |   >  |   大于  |
|   lt  |   <  |   小于  |
|   ge  |   >=  |   大于等于  |
|   le  |   <=  |   小于等于  |

##### Logical expressions（逻辑运算符）:
|   英文写法    |   C语言写法   |   含义  |
|--------------|-----------|-----------|
|   and  |   &&  |   逻辑与  |
|   or  |   ||  |   逻辑或  |
|   xor  |   ^^  |   逻辑异或  |
|   not  |   !  |   逻辑非  |

被程序员们熟知的逻辑异或是一种排除性的或。当其被用在过滤器的两个条件之间时，只有当且仅当其中的一个条件满足时，这样的结果才会被显示在屏幕上。
例如："tcp.dstport 80 xor tcp.dstport 1025"，表示：只有当目的TCP端口为80或者来源于端口1025（但又不能同时满足这两点）时，这样的封包才会被显示。
如果过滤器的语法是正确的，表达式的背景呈绿色。如果呈红色，说明表达式有误。

参考文档：
> - 1. [Wireshark过滤器](http://openmaniak.com/cn/wireshark_filters.php)
> - 2. [wireshark过滤语法总结](http://blog.csdn.net/tskyfree/article/details/41219899)
> - 3. [wireshark 实用过滤表达式](http://www.cnblogs.com/imwtr/articles/4356016.html)


### 1.2 windows下的本地回环抓包方式：
在windows下本地回环不经过网卡，wireshark默认需要安装的wincap不能支持，所以需要使用替换软件进行抓包。
Npcap是一个windows下的libpcap库，用于给wireshark在windows环境下提供支持：
```shell
NPcap is the Windows version of the libpcap library; it includes a driver to support capturing packets. 
```
[https://nmap.org/npcap/](https://github.com/nmap/npcap)给出的说明：
```shell
Npcap is the Nmap Project's packet sniffing library for Windows. It is based on the wonderful Winpcap / Libpcap libraries, but with improved improved speed, portability, security, and efficiency. 
```
安装Npcap首先需要卸载之前已经安装的wincap，然后从[官方下载](https://github.com/nmap/npcap/releases)之后安装。
安装完毕后打开wireshark，就会发现多了一个Npcap Loopback adapter选项，监听这个适配器可以完成对本地回环的测试。

例如调试本地20006端口的TCP/IP访问时，wireshark的显示过滤器设置为：
```shell
tcp&&ip.addr==127.0.0.1&&tcp.port==20006
```
进行一次TCP/IP访问之后，可以看到wireshark已经捕获到了具体的访问信息，这个时候可以停止捕获，然后将捕获结果导出，用于后续深入分析。

参考文档：
> - 1. [wireshark监听本地localhost/127.0.0.1回环网络](http://blog.techbeta.me/2015/12/wireshark-Loopback/)


## 2 网络协议分析：
通过第一章的内容，我们可以获取基本的网络访问结果。接下来就需要对这个网络嗅探结果进入深入分析，查看对应协议的数据包来进行分析协议，在这个过程中就可以找到我们需要的内容了。

### 2.1 TCP/IP协议：
我们编写一个java的socket服务器，然后使用sokit来发送TCP/IP请求到这个服务器进行测试。

#### 2.1.1 准备测试代码和环境：
首先编写一个多线程的Socket服务器类：
```java
import java.io.*;
import java.net.Socket;

public class ServerThread implements Runnable {

    private final static int PORT = 20006;          // socket服务监听的端口号
    private final static String ENCODE = "UTF-8";    // 默认的传输编码集
    final static int BUFFER_SIZE = 4096;            // 一次获取缓存的长度


    private Socket client = null;


    public ServerThread(Socket client) {
        this.client = client;
    }

    // 将输入流转换为字符串
    public static String InputStreamTOString(InputStream in) throws Exception{
        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
        byte[] data = new byte[BUFFER_SIZE];
        int count = -1;
        while((count = in.read(data,0,BUFFER_SIZE)) != -1){
            outStream.write(data, 0, count);
        }
        //data = null;
        return new String(outStream.toByteArray(),"ISO-8859-1");
    }

    // 从client获取输入内容
    public String getSocketClientInput() throws Exception {
        InputStream inStream = this.client.getInputStream();
        String result = InputStreamTOString(inStream);
        return result;
    }

    // 给Client返回

    @Override
    public void run() {
        try {
            System.out.println("进入监听："+this.client.getLocalAddress());
            //获取Socket的输出流，用来向客户端发送数据
            PrintStream out = new PrintStream(this.client.getOutputStream());
            //获取Socket的输入流，用来接收从客户端发送过来的数据
            InputStream inStream = this.client.getInputStream();
            BufferedReader inStreamBufferReader = new BufferedReader(new InputStreamReader(inStream));

            // 开始循环阻塞式监听：
            boolean flag = true;
            while (flag) {
                ByteArrayOutputStream outSteam = new ByteArrayOutputStream();
                byte[] buffer = new byte[BUFFER_SIZE];
                int len = -1;
                // 阻塞式获取返回：
                while ((len = inStream.read(buffer,0,BUFFER_SIZE)) != -1) {
                    // 将获取的返回值写入到字节流中：
                    outSteam.write(buffer, 0, len);
                    // 按照指定的编码进行解析转换为字符串：
                    String str = new String(outSteam.toByteArray(), ENCODE);
                    // 监控输入字符，判断是否需要继续监听
                    if("bye".equals(str)){
                        flag = false;
                        break;
                    }else{
                        //将接收到的字符串前面加上echo，发送到对应的客户端
                        out.println("echo:" + str);
                        // 清空buffer内容
                        buffer = new byte[BUFFER_SIZE];
                        // 清空读入缓存内容
                        outSteam = new ByteArrayOutputStream();
                    }
                }
            }

            // 完成监听，结束任务
            inStreamBufferReader.close();
            out.close();
            client.close();
            System.out.println("关闭监听："+this.client.getLocalAddress());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
然后执行一个实例：
```java
public static void main(String[] args) throws Exception{
        //服务端在20006端口监听客户端请求的TCP连接
        ServerSocket server = new ServerSocket(20006);
        Socket client = null;
        boolean f = true;
        // 设置监听循环，可以获取最大支持的TCP链接数
        while(f){
            // 获取当前端口的链接客户端：
            client = server.accept();
            System.out.println("与客户端："+client.getLocalAddress()+"，连接成功！");

            //为每个客户端连接开启一个线程
            new Thread(new ServerThread(client)).start();
            f = false;
        }
        server.close();
    }
```
注意：在测试程序中通过设置boolean f保证循环只被执行一次，这样才能进入线程中进行调试。

打开wireshark设置，选择本地回环监听，通过设置捕获过滤器来从源头减少干扰，之分析本程序调用产生的网络链接：
```shell
port 20006 && host 127.0.0.1
```
然后让显示过滤器不设置。

#### 2.1.2 程序交互和捕获：
TCP/IP需要三次握手完成一次通信，所以针对当前的程序，需要按照步骤调试来完成基本通信的捕获。

##### （1）建立连接：
首先调试上述程序，启动服务器，然后打开sokit，选中指定的IP和端口点击连接，这个时候就完成了一次TCP/IP通信，可以在wireshark中看到已经捕获到了三条信息：
```shell
1	0.000000	127.0.0.1	127.0.0.1	TCP	108	9849→20006 [SYN] Seq=0 Win=8192 Len=0 MSS=65495 WS=256 SACK_PERM=1
2	0.000042	127.0.0.1	127.0.0.1	TCP	108	20006→9849 [SYN, ACK] Seq=0 Ack=1 Win=8192 Len=0 MSS=65495 WS=256 SACK_PERM=1
3	0.000127	127.0.0.1	127.0.0.1	TCP	84	9849→20006 [ACK] Seq=1 Ack=1 Win=525568 Len=0
```
然后停止wireshark的捕获，将当前信息导出，供后续分析。

##### （2）从客户端发送数据到服务器，然后从服务器返回：
继续用sokit向指定的IP和端口发送一条消息，服务器程序获取消息后处理，然后返回，这个时候完成一次完整的业务交互，可以在wireshark中看到捕获信息：
```shell
1	0.000000	127.0.0.1	127.0.0.1	TCP	128	9849→20006 [PSH, ACK] Seq=1 Ack=1 Win=2053 Len=22
2	0.000074	127.0.0.1	127.0.0.1	TCP	84	20006→9849 [ACK] Seq=1 Ack=23 Win=2053 Len=0
3	9.352698	127.0.0.1	127.0.0.1	TCP	138	20006→9849 [PSH, ACK] Seq=1 Ack=23 Win=2053 Len=27
4	9.352731	127.0.0.1	127.0.0.1	TCP	84	9849→20006 [ACK] Seq=23 Ack=28 Win=2053 Len=0
5	9.352800	127.0.0.1	127.0.0.1	TCP	88	20006→9849 [PSH, ACK] Seq=28 Ack=23 Win=2053 Len=2
6	9.352807	127.0.0.1	127.0.0.1	TCP	84	9849→20006 [ACK] Seq=23 Ack=30 Win=2053 Len=0
```
可以看出，这个交互流程完成了两次TCP/IP握手，并且包含了发送和接受消息的内容。
停止wireshark捕获，将当前结果导出，供后续详细分析。


##### （3）从服务器发送返回数据到客户端，然后从客户端返回：


#### 2.1.3 TCP/IP协议分析：
TCP/IP是一个协议族，通常分不同层次进行开发，每个层次负责不同的通信功能。包含以下四个层次：
> - 1. 链路层，也称作数据链路层或者网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。
> - 2. 网络层，也称作互联网层，处理分组在网络中的活动，例如分组的选路。网络层协议包括IP协议（网际协议）、ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。
> - 3. 运输层主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP为两台主机提供高可靠性的数据通信。他所作的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端通信，因此应用层可以忽略所有这些细节。而另一方面，UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必须的可靠性必须由应用层来提供。
> - 4. 应用层负责处理特定的应用程序细节。包括Telnet（远程登录）、FTP（文件传输协议）、SMTP（简单邮件传送协议）以及SNMP（简单网络管理协议）等。

wireshark捕获的信息也包含上述这四个层次的内容，并且已经分析归类，对应关系为：
> - 1. Frame:   物理层的数据帧概况；
> - 2. Ethernet II: 数据链路层以太网帧头部信息；
> - 3. Internet Protocol Version 4: 互联网层IP包头部信息；
> - 4. Transmission Control Protocol:  传输层的数据段头部信息，此处是TCP；
> - 5. Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议等基于TCP/IP协议的应用层协议内容。



上述程序交互的过程中抓到了三种包：
> - 1. 客户端和服务器建立链接的TCP/IP通信包；
> - 2. 客户端发送消息到服务器，然后获取返回数据的TCP/IP通信包；
> - 3. 服务器给客户端发送消息，然后客户端返回数据到服务器的TCP/IP通信包。

现在我们来针对这三种包统一分析，完整的看到整个客户端和服务器之间的TCP/IP交互过程。‘

参考文档：
> - 1. [wireshark抓包图解 TCP三次握手/四次挥手详解](http://www.seanyxie.com/wireshark%E6%8A%93%E5%8C%85%E5%9B%BE%E8%A7%A3-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/)



##### （1）建立连接：
使用wireshark打开上述测试1的导出数据包，

##### （2）从客户端发送数据到服务器，然后从服务器返回：

##### （3）从服务器发送返回数据到客户端，然后从客户端返回：